This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: ufr-lib/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
scripts/
  batch_cmacs.py
  card_types.py
  hashed_cmacs.py
  ntag424_programmer.py
  setup_route.py
src/
  backend/
    main.mo
    routes.mo
    scan.mo
    sha.mo
  declarations/
    backend/
      backend.did
      backend.did.d.ts
      backend.did.js
      index.d.ts
      index.js
    frontend/
      frontend.did
      frontend.did.d.ts
      frontend.did.js
      index.d.ts
      index.js
  frontend/
    src/
      routes/
        page/
          +page.svelte
        +layout.ts
        +page.svelte
        layout.svelte
      stores/
        ic.ts
      app.css
      app.d.ts
      app.html
    static/
      edge.html
.eslintignore
.eslintrc.cjs
.gitignore
.npmrc
.prettierignore
.prettierrc
cmacs.json
dfx.json
Makefile
package.json
svelte.config.js
tsconfig.json
vite.config.ts

================================================================
Files
================================================================

================
File: scripts/batch_cmacs.py
================
#!/usr/bin/env python3
import json
import subprocess
import sys

def split_list(lst, batch_size):
    return [lst[i:i + batch_size] for i in range(0, len(lst), batch_size)]

def convert_to_candid(data):
    # Properly quote each string
    quoted_strings = [f'"{x}"' for x in data]
    return '(vec {' + ';'.join(quoted_strings) + '})'

def main():
    # Updated to accept an optional --ic flag
    if len(sys.argv) not in [4, 5]:
        print("Usage: python3 batch_cmacs.py <cmacs_file> <canister_name> <page_path> [--ic]")
        sys.exit(1)

    json_file = sys.argv[1]
    canister_name = sys.argv[2]
    page_path = sys.argv[3]
    
    # Check if --ic flag is present
    ic_mode = False
    if len(sys.argv) == 5 and sys.argv[4] == "--ic":
        ic_mode = True
    
    batch_size = 1500  # Max batch size for terminal

    # Read the full JSON file
    with open(json_file, 'r') as f:
        all_cmacs = json.load(f)

    # Split into batches
    batches = split_list(all_cmacs, batch_size)
    total_batches = len(batches)

    print(f"Processing {len(all_cmacs)} CMACs in {total_batches} batches")
    
    # Add --ic flag to dfx command if in IC mode
    ic_flag = "--ic " if ic_mode else ""

    # Process each batch
    for i, batch in enumerate(batches, 1):
        print(f"Processing batch {i}/{total_batches}")
        candid_data = convert_to_candid(batch)
        
        # Call the canister with the batch, including --ic flag if needed
        cmd = f'dfx canister call {ic_flag}{canister_name} append_route_cmacs \'("{page_path}", {candid_data})\''
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
        
        if result.returncode != 0:
            print(f"Error processing batch {i}: {result.stderr}")
            sys.exit(1)
        
        print(f"Successfully processed batch {i}")

if __name__ == "__main__":
    main()

================
File: scripts/card_types.py
================
DLOGIC_CARD_TYPE = {
    0x00: 'DL_NO_CARD',
    0x01: 'DL_MIFARE_ULTRALIGHT',
    0x02: 'DL_MIFARE_ULTRALIGHT_EV1_11',
    0x03: 'DL_MIFARE_ULTRALIGHT_EV1_21',
    0x04: 'DL_MIFARE_ULTRALIGHT_C',
    0x05: 'DL_NTAG_203',
    0x06: 'DL_NTAG_210',
    0x07: 'DL_NTAG_212',
    0x08: 'DL_NTAG_213',
    0x09: 'DL_NTAG_215',
    0x0A: 'DL_NTAG_216',
    0x0B: 'DL_MIKRON_MIK640D',
    0x0C: 'NFC_T2T_GENERIC',
    0x0D: 'DL_NT3H_1101',
    0x0E: 'DL_NT3H_1201',
    0x0F: 'DL_NT3H_2111',
    0x10: 'DL_NT3H_2211',
    0x11: 'DL_NTAG_413_DNA',
    0x12: 'DL_NTAG_424_DNA',
    0x13: 'DL_NTAG_424_DNA_TT',
    0x14: 'DL_NTAG_210U',
    0x15: 'DL_NTAG_213_TT',
    0x19: 'DL_MIFARE_CLASSIC_2K',

    0x20: 'DL_MIFARE_MINI',
    0x21: 'DL_MIFARE_CLASSIC_1K',
    0x22: 'DL_MIFARE_CLASSIC_4K',
    0x23: 'DL_MIFARE_PLUS_S_2K_SL0',
    0x24: 'DL_MIFARE_PLUS_S_4K_SL0',
    0x25: 'DL_MIFARE_PLUS_X_2K_SL0',
    0x26: 'DL_MIFARE_PLUS_X_4K_SL0',
    0x27: 'DL_MIFARE_DESFIRE',
    0x28: 'DL_MIFARE_DESFIRE_EV1_2K',
    0x29: 'DL_MIFARE_DESFIRE_EV1_4K',
    0x2A: 'DL_MIFARE_DESFIRE_EV1_8K',
    0x2B: 'DL_MIFARE_DESFIRE_EV2_2K',
    0x2C: 'DL_MIFARE_DESFIRE_EV2_4K',
    0x2D: 'DL_MIFARE_DESFIRE_EV2_8K',
    0x2E: 'DL_MIFARE_PLUS_S_2K_SL1',
    0x2F: 'DL_MIFARE_PLUS_X_2K_SL1',
    0x30: 'DL_MIFARE_PLUS_EV1_2K_SL1',
    0x31: 'DL_MIFARE_PLUS_X_2K_SL2',
    0x32: 'DL_MIFARE_PLUS_S_2K_SL3',
    0x33: 'DL_MIFARE_PLUS_X_2K_SL3',
    0x34: 'DL_MIFARE_PLUS_EV1_2K_SL3',
    0x35: 'DL_MIFARE_PLUS_S_4K_SL1',
    0x36: 'DL_MIFARE_PLUS_X_4K_SL1',
    0x37: 'DL_MIFARE_PLUS_EV1_4K_SL1',
    0x38: 'DL_MIFARE_PLUS_X_4K_SL2',
    0x39: 'DL_MIFARE_PLUS_S_4K_SL3',
    0x3A: 'DL_MIFARE_PLUS_X_4K_SL3',
    0x3B: 'DL_MIFARE_PLUS_EV1_4K_SL3',
    0x3C: 'DL_MIFARE_PLUS_SE_SL0',
    0x3D: 'DL_MIFARE_PLUS_SE_SL1',
    0x3E: 'DL_MIFARE_PLUS_SE_SL3',
    0x3F: 'DL_MIFARE_DESFIRE_LIGHT',

    0x40: 'DL_GENERIC_ISO14443_4',
    0x41: 'DL_GENERIC_ISO14443_4_TYPE_B',
    0x42: 'DL_GENERIC_ISO14443_3_TYPE_B',
    0x43: 'DL_MIFARE_PLUS_EV1_2K_SL0',
    0x44: 'DL_MIFARE_PLUS_EV1_4K_SL0',
    0x45: 'DL_MIFARE_DESFIRE_EV3_2K',
    0x46: 'DL_MIFARE_DESFIRE_EV3_4K',
    0x47: 'DL_MIFARE_DESFIRE_EV3_8K',

    0x60: 'DL_MOBILE_AID',
    0x6A: 'DL_APPLE_VAS_V1',
    0x6B: 'DL_APPLE_VAS_V2',
    0x80: 'DL_IMEI_UID',

    0x82: 'M24SR02',
    0x8A: 'M24SR02_AUTOMOTIVE',
    0x86: 'M24SR04',
    0x8E: 'M24SR04_AUTOMOTIVE',
    0x85: 'M24SR16',
    0x8D: 'M24SR16_AUTOMOTIVE',
    0x84: 'M24SR64',
    0x8C: 'M24SR64_AUTOMOTIVE',

    0xA0: 'DLSigner81',
    0xA1: 'DLSigner22',
    0xA2: 'DLSigner30',
    0xA3: 'DLSigner10',
    0xAA: 'DLSigner145'
}

================
File: scripts/hashed_cmacs.py
================
from Crypto.Cipher import AES
from Crypto.Hash import CMAC
from Crypto.Hash import SHA256
import binascii
import argparse
import hashlib
import json

parser = argparse.ArgumentParser(
    prog='CMAC Generator',
    description='Generate CMAC hashes for NFC authentication'
)

parser.add_argument('-k', '--key', required=True, type=str, help='The key to use for the SDMMAC')
parser.add_argument('-u', '--uid', required=True, type=str, help='The UID to use for the SDMMAC')
parser.add_argument('-c', '--count', default=42000, type=int, help='The count value')
parser.add_argument('-o', '--output', required=True, type=str, help='Output JSON file path')

def decode(hex_str):
    return binascii.unhexlify(hex_str)

def encode(bytes_str):
    return binascii.hexlify(bytes_str).decode().upper()

def SDMMAC(count, uid, mKey):
    cmac = CMAC.new(decode(mKey), ciphermod=AES)
    sv1 = "3CC300010080" + uid + count
    cmac.update(decode(sv1))
    k1 = encode(cmac.digest())
    
    fullSDMMAC = CMAC.new(decode(k1), ciphermod=AES)
    fullSDMMAC.update(b'')
    
    fullString = encode(fullSDMMAC.digest())
    
    s1 = fullString[2:4]
    s2 = fullString[6:8]
    s3 = fullString[10:12]
    s4 = fullString[14:16]
    s5 = fullString[18:20]
    s6 = fullString[22:24]
    s7 = fullString[26:28]
    s8 = fullString[30:32]
    
    return (s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8).upper()

def int_to_little_endian_3byte_hex(num):
    hex_string = format(num, '06x')
    return ''.join(reversed([hex_string[i:i+2] for i in range(0, len(hex_string), 2)]))

def generate_hashes(count, uid, key):
    return [hashlib.sha256(SDMMAC(int_to_little_endian_3byte_hex(i), uid, key).encode('utf-8')).hexdigest() 
            for i in range(1, count)]

def main():
    args = parser.parse_args()
    
    if len(args.key) != 32:
        print("Key must be 32 characters long")
        return

    hashes = generate_hashes(args.count, args.uid, args.key)
    
    # Save hashes to JSON file
    with open(args.output, 'w') as f:
        json.dump(hashes, f)
    
    print(f"Generated {len(hashes)} hashes and saved to {args.output}")

if __name__ == "__main__":
    main()

================
File: scripts/ntag424_programmer.py
================
import ctypes
from ctypes import *
import sys
import platform
import os
import time
import card_types
from datetime import datetime
##########################################################################
# uFCODER - LOAD LIBRARY
##########################################################################

print("sys.platform = " + sys.platform)
if sys.platform.startswith('win'):
    import msvcrt
    from ctypes import windll
    # Used for specifying lib for OS version, 32/64bit
    if platform.architecture()[0] == '32bit':
        uFR = ctypes.windll.LoadLibrary(
            "ufr-lib//windows//x86//uFCoder-x86.dll")
    elif platform.architecture()[0] == '64bit':
        uFR = ctypes.windll.LoadLibrary(
            "ufr-lib//windows//x86_64//uFCoder-x86_64.dll")
elif sys.platform.startswith('linux'):
    # used for specifying lib for OS version, 32/64bit
    if os.uname()[4][:3] == 'arm':
        uFR = cdll.LoadLibrary("ufr-lib//linux//arm-hf//libuFCoder-armhf.so")
    elif platform.architecture()[0] == '32bit':
        uFR = cdll.LoadLibrary("ufr-lib//linux//x86//libuFCoder-x86.so")
    elif platform.architecture()[0] == '64bit':
        uFR = cdll.LoadLibrary("ufr-lib//linux//x86_64//libuFCoder-x86_64.so")
elif sys.platform.startswith('darwin'):
    uFR = cdll.LoadLibrary("ufr-lib//macos//x86_64//libuFCoder-x86_64.dylib")
else:
    print("Platform not recognized? os.uname = " + os.uname)

##########################################################################
# uFCODER API - IMPORT FUNCTIONS
##########################################################################

def ReaderOpenEx(reader_type, port_name, port_interface, arg):
    openReader = uFR.ReaderOpenEx
    openReader.argtypes = (c_uint32, c_char_p, c_uint32, c_char_p)
    openReader.restype = c_uint
    b = c_char_p(port_name.encode('utf-8'))
    c = c_char_p(arg.encode('utf-8'))

    return openReader(reader_type, b, port_interface, c)

##########################################################################

def ReaderOpen():
    openReader = uFR.ReaderOpen

    return openReader()

##########################################################################

def ReaderUISignal(light, sound):
    uiSignal = uFR.ReaderUISignal
    uiSignal.argtypes = (c_ubyte, c_ubyte)
    uiSignal.restype = c_uint
    uiSignal(light, sound)

##########################################################################

def ReaderClose():
    func = uFR.ReaderClose

    return func()

###########################f###############################################

def GetCardIdEx(sak, uid, uid_size):
    getCardIdEx = uFR.GetCardIdEx
    getCardIdEx.argtypes = [ POINTER(c_ubyte), (c_ubyte * 11), POINTER(c_ubyte)]
    getCardIdEx.restype = c_uint

    return getCardIdEx(byref(sak), uid, byref(uid_size))

##########################################################################

def GetDlogicCardType(card_type):
    getCardType = uFR.GetDlogicCardType
    getCardType.argtypes = [ POINTER(c_ubyte)]
    getCardType.restype = c_uint

    return getCardType(byref(card_type))

##########################################################################
##########################################################################

def nt4h_set_global_parameters(file_no, key_no, communication_mode):

    nt4h_set_global_parametersFunc = uFR.nt4h_set_global_parameters
    nt4h_set_global_parametersFunc.argtypes = [
    c_ubyte,  # file_no (uint8_t)
    c_ubyte,  # key_no (uint8_t)
    c_ubyte   # communication_mode (uint8_t)
    ]

    nt4h_set_global_parameters.restype = c_uint

    return nt4h_set_global_parametersFunc(file_no, key_no, communication_mode)
##########################################################################
def nt4h_change_sdm_file_settings_pk(aes_key_ext, file_no, key_no, curr_communication_mode, new_communication_mode, 
                                    read_key_no, write_key_no, read_write_key_no, change_key_no,
                                    uid_enable, read_ctr_enable, read_ctr_limit_enable, enc_file_data_enable,
                                    meta_data_key_no, file_data_read_key_no, read_ctr_key_no,
                                    uid_offset, read_ctr_offset, picc_data_offset, mac_input_offset,
                                    enc_offset, enc_length, mac_offset, read_ctr_limit):

    nt4h_change_sdm_file_settings_pkFunc = uFR.nt4h_change_sdm_file_settings_pk
    nt4h_change_sdm_file_settings_pkFunc.argtypes = [
        ctypes.POINTER(c_ubyte),   # uint8_t *aes_key_ext
        c_ubyte,                  # uint8_t file_no
        c_ubyte,                  # uint8_t key_no
        c_ubyte,                  # uint8_t curr_communication_mode
        c_ubyte,                  # uint8_t new_communication_mode

        c_ubyte,                  # uint8_t read_key_no
        c_ubyte,                  # uint8_t write_key_no
        c_ubyte,                  # uint8_t read_write_key_no
        c_ubyte,                  # uint8_t change_key_no

        c_ubyte,                  # uint8_t uid_enable
        c_ubyte,                  # uint8_t read_ctr_enable
        c_ubyte,                  # uint8_t read_ctr_limit_enable
        c_ubyte,                  # uint8_t enc_file_data_enable

        c_ubyte,                  # uint8_t meta_data_key_no
        c_ubyte,                  # uint8_t file_data_read_key_no
        c_ubyte,                  # uint8_t read_ctr_key_no

        c_uint,                   # uint8_t uid_offset
        c_uint,                   # uint8_t read_ctr_offset
        c_uint,                   # uint8_t picc_data_offset
        c_uint,                   # uint8_t mac_input_offset

        c_uint,                   # uint8_t enc_offset
        c_uint,                   # uint8_t enc_length
        c_uint,                   # uint8_t mac_offset
        c_uint,                   # uint8_t read_ctr_limit
    ]
    nt4h_change_sdm_file_settings_pkFunc.restype = c_uint

    return nt4h_change_sdm_file_settings_pkFunc(aes_key_ext, file_no, key_no, curr_communication_mode, new_communication_mode, 
                                    read_key_no, write_key_no, read_write_key_no, change_key_no,
                                    uid_enable, read_ctr_enable, read_ctr_limit_enable, enc_file_data_enable,
                                    meta_data_key_no, file_data_read_key_no, read_ctr_key_no,
                                    uid_offset, read_ctr_offset, picc_data_offset, mac_input_offset,
                                    enc_offset, enc_length, mac_offset, read_ctr_limit)

##########################################################################

def nt4h_tt_change_sdm_file_settings_pk(aes_key_ext, file_no, key_no, curr_communication_mode, new_communication_mode, 
                                    read_key_no, write_key_no, read_write_key_no, change_key_no,
                                    uid_enable, read_ctr_enable, read_ctr_limit_enable, enc_file_data_enable,
                                    meta_data_key_no, file_data_read_key_no, read_ctr_key_no,
                                    uid_offset, read_ctr_offset, picc_data_offset, mac_input_offset,
                                    enc_offset, enc_length, mac_offset, read_ctr_limit,
                                    tt_status_enable, tt_status_offset):

    nt4h_tt_change_sdm_file_settings_pkFunc = uFR.nt4h_tt_change_sdm_file_settings_pk
    nt4h_tt_change_sdm_file_settings_pkFunc.argtypes = [
        ctypes.POINTER(c_ubyte),  # uint8_t *aes_key_ext
        c_ubyte,                  # uint8_t file_no
        c_ubyte,                  # uint8_t key_no
        c_ubyte,                  # uint8_t curr_communication_mode
        c_ubyte,                  # uint8_t new_communication_mode

        c_ubyte,                  # uint8_t read_key_no
        c_ubyte,                  # uint8_t write_key_no
        c_ubyte,                  # uint8_t read_write_key_no
        c_ubyte,                  # uint8_t change_key_no

        c_ubyte,                  # uint8_t uid_enable
        c_ubyte,                  # uint8_t read_ctr_enable
        c_ubyte,                  # uint8_t read_ctr_limit_enable
        c_ubyte,                  # uint8_t enc_file_data_enable

        c_ubyte,                  # uint8_t meta_data_key_no
        c_ubyte,                  # uint8_t file_data_read_key_no
        c_ubyte,                  # uint8_t read_ctr_key_no

        c_uint,                   # uint8_t uid_offset
        c_uint,                   # uint8_t read_ctr_offset
        c_uint,                   # uint8_t picc_data_offset
        c_uint,                   # uint8_t mac_input_offset

        c_uint,                   # uint8_t enc_offset
        c_uint,                   # uint8_t enc_length
        c_uint,                   # uint8_t mac_offset
        c_uint,                   # uint8_t read_ctr_limit

        c_ubyte,                   # uint8_t tt_status_enable
        c_uint,                   # uint8_t tt_status_offset
    ]
    nt4h_tt_change_sdm_file_settings_pkFunc.restype = c_uint

    return nt4h_tt_change_sdm_file_settings_pkFunc(aes_key_ext, file_no, key_no, curr_communication_mode, new_communication_mode, 
                                    read_key_no, write_key_no, read_write_key_no, change_key_no,
                                    uid_enable, read_ctr_enable, read_ctr_limit_enable, enc_file_data_enable,
                                    meta_data_key_no, file_data_read_key_no, read_ctr_key_no,
                                    uid_offset, read_ctr_offset, picc_data_offset, mac_input_offset,
                                    enc_offset, enc_length, mac_offset, read_ctr_limit,
                                    tt_status_enable, tt_status_offset)

##########################################################################

def nt4h_tt_get_file_settings(file_no, file_type, comm_mode, sdm_enable, file_size,
    read_key_no, write_key_no, read_write_key_no, change_key_no,
    uid_enable, read_ctr_enable, read_ctr_limit_enable, enc_file_data_enable,
    meta_data_key_no, file_data_read_key_no, read_ctr_key_no,
    uid_offset, read_ctr_offset, picc_data_offset,
    mac_input_offset, enc_offset, enc_length, mac_offset, read_ctr_limit,
    tt_status_enable, tt_status_offset):
    
    nt4h_tt_get_file_settingsFunc = uFR.nt4h_tt_get_file_settings
    nt4h_tt_get_file_settingsFunc.argtypes = [
        c_ubyte,                  # uint8_t file_no

        ctypes.POINTER(c_ubyte),  # uint8_t file_type
        ctypes.POINTER(c_ubyte),  # uint8_t communication_mode
        ctypes.POINTER(c_ubyte),  # uint8_t sdm_enable
        ctypes.POINTER(c_uint),   # uint8_t file_size

        ctypes.POINTER(c_ubyte),    # uint8_t read_key_no
        ctypes.POINTER(c_ubyte),    # uint8_t write_key_no
        ctypes.POINTER(c_ubyte),    # uint8_t read_write_key_no
        ctypes.POINTER(c_ubyte),    # uint8_t change_key_no

        ctypes.POINTER(c_ubyte),    # uint8_t uid_enable
        ctypes.POINTER(c_ubyte),    # uint8_t read_ctr_enable
        ctypes.POINTER(c_ubyte),    # uint8_t read_ctr_limit_enable
        ctypes.POINTER(c_ubyte),    # uint8_t enc_file_data_enable

        ctypes.POINTER(c_ubyte),    # uint8_t meta_data_key_no
        ctypes.POINTER(c_ubyte),    # uint8_t file_data_read_key_no
        ctypes.POINTER(c_ubyte),    # uint8_t read_ctr_key_no

        ctypes.POINTER(c_uint),    # uint8_t uid_offset
        ctypes.POINTER(c_uint),    # uint8_t read_ctr_offset
        ctypes.POINTER(c_uint),    # uint8_t picc_data_offset
        ctypes.POINTER(c_uint),    # uint8_t mac_input_offset
        ctypes.POINTER(c_uint),    # uint8_t enc_offset
        ctypes.POINTER(c_uint),    # uint8_t enc_length
        ctypes.POINTER(c_uint),    # uint8_t mac_offset

        ctypes.POINTER(c_uint),    # read_ctr_limit
        ctypes.POINTER(c_ubyte),   # tt_status_enable
        ctypes.POINTER(c_uint),    # tt_status_offset
    ]

    nt4h_tt_get_file_settingsFunc.restype = c_uint

    return nt4h_tt_get_file_settingsFunc(file_no, file_type, comm_mode, sdm_enable, file_size,
    read_key_no, write_key_no, read_write_key_no, change_key_no,
    uid_enable, read_ctr_enable, read_ctr_limit_enable, enc_file_data_enable,
    meta_data_key_no, file_data_read_key_no, read_ctr_key_no,
    uid_offset, read_ctr_offset, picc_data_offset,
    mac_input_offset, enc_offset, enc_length, mac_offset, read_ctr_limit,
    tt_status_enable, tt_status_offset)

##########################################################################

def nt4h_check_sdm_mac(sdm_read_counter, uid, auth_key, mac_in_data, mac_in_len, sdm_mac):
    nt4h_check_sdm_macFunc = uFR.nt4h_check_sdm_mac
    nt4h_check_sdm_macFunc.argtypes = [
        c_uint,                     # uint32_t sdm_read_counter
        ctypes.POINTER(c_ubyte),    # uint8_t *uid
        ctypes.POINTER(c_ubyte),    # uint8_t *auth_key
        ctypes.POINTER(c_ubyte),    # uint8_t *mac_in_data
        c_ubyte,                    # uint8_t mac_in_len
        ctypes.POINTER(c_ubyte),   # const uint8_t *sdm_mac
    ]
    nt4h_check_sdm_macFunc.restype = c_uint
    return nt4h_check_sdm_macFunc(sdm_read_counter, uid, auth_key, mac_in_data, mac_in_len, sdm_mac)

##########################################################################

def nt4h_change_key_pk(auth_key, key_no, new_key, old_key):
    nt4h_change_key_pkFunc = uFR.nt4h_change_key_pk
    nt4h_change_key_pkFunc.argtypes = [
        ctypes.POINTER(c_ubyte),    # uint8_t *auth_key
        c_uint,                     # uint8_t key_no
        ctypes.POINTER(c_ubyte),    # uint8_t *old_key
        ctypes.POINTER(c_ubyte),    # uint8_t *new_key
    ]
    nt4h_change_key_pkFunc.restype = c_uint
    return nt4h_change_key_pkFunc(auth_key, key_no, new_key, old_key)

##########################################################################

def LinearWrite_PK(data, linear_address, length, bytes_written, auth_mode, key):
    #UFR_STATUS DL_API LinearWrite_PK(IN const uint8_t *data, uint16_t linear_address, uint16_t length, VAR uint16_t *bytes_written,
    #                                 uint8_t auth_mode, IN const uint8_t *key);

    LinearWrite_PKFunc = uFR.LinearWrite_PK
    LinearWrite_PKFunc.argtypes = [
        ctypes.POINTER(c_ubyte),   # const uint8_t *data
        c_uint16,                 # uint16_t linear_address
        c_uint16,                 # uint16_t length
        POINTER(c_uint16),        # uint16_t *bytes_written
        c_ubyte,                  # uint8_t auth_mode
        ctypes.POINTER(c_ubyte)   # const uint8_t *key
    ]

    LinearWrite_PKFunc.restype = c_uint
    return LinearWrite_PKFunc(data, linear_address, length, byref(bytes_written), auth_mode, key)

##########################################################################

def LinearRead_PK(data, linear_address, length, bytes_written, auth_mode, key):
    #UFR_STATUS DL_API LinearWrite_PK(IN const uint8_t *data, uint16_t linear_address, uint16_t length, VAR uint16_t *bytes_written,
    #                                 uint8_t auth_mode, IN const uint8_t *key);

    LinearRead_PKFunc = uFR.LinearRead_PK
    LinearRead_PKFunc.argtypes = [
        ctypes.POINTER(c_ubyte),   # const uint8_t *data
        c_uint16,                 # uint16_t linear_address
        c_uint16,                 # uint16_t length
        POINTER(c_uint16),        # uint16_t *bytes_written
        c_ubyte,                  # uint8_t auth_mode
        ctypes.POINTER(c_ubyte)   # const uint8_t *key
    ]

    LinearRead_PKFunc.restype = c_uint
    return LinearRead_PKFunc(data, linear_address, length, byref(bytes_written), auth_mode, key)

####################################################################################################################################################

def LinearRead(data, linear_address, length, bytes_written, auth_mode, key):
    #UFR_STATUS DL_API LinearWrite_PK(IN const uint8_t *data, uint16_t linear_address, uint16_t length, VAR uint16_t *bytes_written,
    #                                 uint8_t auth_mode, IN const uint8_t *key);

    LinearReadFunc = uFR.LinearRead
    LinearReadFunc.argtypes = [
        ctypes.POINTER(c_ubyte),   # const uint8_t *data
        c_uint16,                 # uint16_t linear_address
        c_uint16,                 # uint16_t length
        POINTER(c_uint16),        # uint16_t *bytes_read
        c_ubyte,                  # uint8_t auth_mode
        c_ubyte   # const uint8_t *key
    ]

    LinearReadFunc.restype = c_uint
    return LinearReadFunc(data, linear_address, length, byref(bytes_written), auth_mode, key)
##########################################################################
##########################################################################
##########################################################################
def read_and_verify_sdm_data():
    status = 0
    global_file_no = c_ubyte(2)
    global_key_no = c_ubyte(14) # NDEF for SDM must be set as 'Read Access - 14'
    global_comm_mode = c_ubyte(0)

    default_aes_key = (c_ubyte * 16)()
    memset(default_aes_key, 0, ctypes.sizeof(default_aes_key))

    file_no = c_ubyte(2)

    file_type = c_ubyte(0)
    sdm_enable = c_ubyte(0)
    file_size = c_uint(0)

    comm_mode = c_ubyte(0)

    read_key_no = c_ubyte(0)
    write_key_no = c_ubyte(0)
    read_write_key_no = c_ubyte(0)
    change_key_no = c_ubyte(0)

    uid_enable = c_ubyte(0)
    read_ctr_enable = c_ubyte(0)
    read_ctr_limit_enable = c_ubyte(0)
    enc_file_data_enable = c_ubyte(0)

    meta_data_key_no = c_ubyte(0)
    file_data_read_key_no = c_ubyte(0)
    read_ctr_key_no = c_ubyte(0)

    uid_offset = c_uint(0)
    read_ctr_offset = c_uint(0)
    picc_data_offset = c_uint(0)
    mac_input_offset = c_uint(0)

    enc_offset = c_uint(0)
    enc_length = c_uint(0)
    mac_offset = c_uint(0)
    read_ctr_limit = c_uint(0)

    tt_status_enable = c_ubyte(0)
    tt_status_offset = c_uint(0)

    status = nt4h_tt_get_file_settings(file_no, file_type, comm_mode, sdm_enable, file_size,
            read_key_no, write_key_no, read_write_key_no, change_key_no,
            uid_enable, read_ctr_enable, read_ctr_limit_enable, enc_file_data_enable,
            meta_data_key_no, file_data_read_key_no, read_ctr_key_no,
            uid_offset, read_ctr_offset, picc_data_offset,
            mac_input_offset, enc_offset, enc_length, mac_offset, read_ctr_limit,
            tt_status_enable, tt_status_offset)
    status_str = "nt4h_tt_get_file_settings(): ", uFR_NT4H_Status2String(status)
    print(status_str)
    

    if (status == 0):
        #print("file_type: ", file_type)
        #print("comm_mode: ", comm_mode)
        #print("sdm_enable: ", sdm_enable)
        #print("file_size: ", file_size)
        #print("read_key_no: ", read_key_no)
        #print("write_key_no: ", write_key_no)
        #print("read_write_key_no: ", read_write_key_no)
        #print("change_key_no: ", change_key_no)
        #print("uid_enable: ", uid_enable)
        #print("read_ctr_enable: ", read_ctr_enable)
        #print("read_ctr_limit_enable: ", read_ctr_limit_enable)
        #print("enc_file_data_enable: ", enc_file_data_enable)
        #print("meta_data_key_no: ", meta_data_key_no)
        #print("file_data_read_key_no: ", file_data_read_key_no)
        #print("read_ctr_key_no: ", read_ctr_key_no)
        print("uid_offset: ", uid_offset)
        print("read_ctr_offset: ", read_ctr_offset)
        #print("picc_data_offset: ", picc_data_offset)
        #print("mac_input_offset: ", mac_input_offset)
        #print("enc_offset: ", enc_offset)
        #print("enc_length: ", enc_length)
        print("mac_offset: ", mac_offset)
        #print("read_ctr_limit: ", read_ctr_limit)
        #print("tt_status_enable: ", tt_status_enable)
        #print("tt_status_offset: ", tt_status_offset)
    else:
        return status
    sdm_mode = (sdm_enable.value == 1) and (comm_mode.value == 0) and (read_key_no.value == 0x0E)
    if (sdm_mode == 1):

        status = nt4h_set_global_parameters(global_file_no, global_key_no, global_comm_mode)
        status_str = "nt4h_set_global_parameters(): ", uFR_NT4H_Status2String(status)
        print(status_str)

        if (status != 0):
            return status

        data = (c_ubyte * 256)()
        memset(data, 0, ctypes.sizeof(data))
        read_len = c_uint16(188)
        bytes_read = c_uint16()
        auth_mode = c_ubyte(T4T_AUTHENTICATION["T4T_WITHOUT_PWD_AUTH"])
        status = LinearRead(data, 0, read_len, bytes_read, auth_mode, 0)
        status_str = "LinearRead_PK(): ", uFR_NT4H_Status2String(status)
        print(status_str)
        if (status != 0):
            return status
        
        #print("Data:", ", ".join(f"0x{byte:02X}" for byte in data))
        
        sliced_uid_buffer = slice_c_ubyte_buffer(data, uid_offset.value, uid_offset.value + 14)
        
        hex_uid_string = ''.join(chr(b) for b in sliced_uid_buffer)
        hex_uid_buffer = string_to_hex_buffer(hex_uid_string)
        #print("hex_uid_buffer")
        #print(hex_uid_buffer)

        sliced_sdm_read_counter_buffer = slice_c_ubyte_buffer(data, read_ctr_offset.value, read_ctr_offset.value + 6)
        hex_ctr_string = ''.join(chr(b) for b in sliced_sdm_read_counter_buffer)
        sdm_read_counter = int(hex_ctr_string, 16)
        #print(sdm_read_counter)

        ascii_mac_in = (c_ubyte * 256)()
        memset(ascii_mac_in, 0, ctypes.sizeof(ascii_mac_in))

        mac_in_len = c_ubyte(0)

        sliced_sdm_mac_buffer = slice_c_ubyte_buffer(data, mac_offset.value, mac_offset.value + 16)
        sdm_mac_str = ''.join(chr(b) for b in sliced_sdm_mac_buffer)
        sdm_mac_buffer = string_to_hex_buffer(sdm_mac_str)

        status = nt4h_check_sdm_mac(sdm_read_counter, hex_uid_buffer, default_aes_key, ascii_mac_in, mac_in_len, sdm_mac_buffer)
        status_str = "nt4h_check_sdm_mac(): ", uFR_NT4H_Status2String(status)
        print(status_str)
    else:
        print("File is not in SDM mode.")
    return status
##########################################################################
def log_to_file(uid_str, message, status=None):
    """
    Log messages to a file named with the card's UID.
    
    Args:
        uid_str (str): Card UID used for filename
        message (str): Message to log
        status (int, optional): Status code if applicable
    """
    filename = f"{uid_str}.txt"
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    with open(filename, 'a') as f:
        log_entry = f"[{timestamp}] {message}"
        if status is not None:
            log_entry += f" (Status: {uFR_NT4H_Status2String(status)})"
        f.write(log_entry + "\n")
        
    # Still print to console for immediate feedback
    print(message)

##########################################################################
T4T_AUTHENTICATION = {
    "T4T_WITHOUT_PWD_AUTH": 0x60,
    "T4T_PK_PWD_AUTH": 0x80,
    "T4T_RKA_PWD_AUTH": 0x02,
}
##########################################################################
def GetDllVersionStr():
    GetDllVersionStrFunc = uFR.GetDllVersionStr
    GetDllVersionStrFunc.restype = ctypes.c_char_p

    return GetDllVersionStrFunc().decode('utf-8')
##########################################################################
def UFRStatus2String(status):
    ufrStatus2String = uFR.UFR_Status2String
    ufrStatus2String.argtypes = [ c_uint32 ]
    ufrStatus2String.restype = ctypes.c_char_p

    return ufrStatus2String(status).decode('utf-8')
##########################################################################
def uFR_NT4H_Status2String(status):
    if status < 0xC0 or status > 0xCB:
        return UFRStatus2String(status)
    else:
        nt4h_status = f"[0x{status:02X} ({status})] "
        nt4h_status_dict = {
            0xC0: 'NT4H_COMMAND_ABORTED',
            0xC1: 'NT4H_LENGTH_ERROR',
            0xC2: 'NT4H_PARAMETER_ERROR',
            0xC3: 'NT4H_NO_SUCH_KEY',
            0xC4: 'NT4H_PERMISSION_DENIED',
            0xC5: 'NT4H_AUTHENTICATION_DELAY',
            0xC6: 'NT4H_MEMORY_ERROR',
            0xC7: 'NT4H_INTEGRITY_ERROR',
            0xC8: 'NT4H_FILE_NOT_FOUND',
            0xC9: 'NT4H_BOUNDARY_ERROR',
            0xCA: 'NT4H_INVALID_MAC',
            0xCB: 'NT4H_NO_CHANGES'
        }
        nt4h_status += nt4h_status_dict.get(status, '')
        return nt4h_status
##########################################################################
def uid_to_string(uid, uid_size):
    """
    Convert a UID (c_ubyte array) to a string with colon-separated hex bytes.
    
    :param uid: A ctypes array of c_ubyte elements representing the UID.
    :param uid_size: The size of the UID array.
    :return: A colon-separated hex string representation of the UID.
    """
    uid_str = '-'.join(f'{uid[n]:02x}' for n in range(uid_size.value)).upper()
    return uid_str
##########################################################################
def generate_random_aes_key_hex():
    """
    Generate a random 16-byte AES key and return it as a hex string.
    
    :return: A 32-character hexadecimal string representing the AES key.
    """
    key = os.urandom(16)  # Generate 16 random bytes
    return key.hex().upper()  # Convert to a hexadecimal string
##########################################################################
# Function to create a slice of the buffer
def slice_c_ubyte_buffer(buffer, start, end):
    if start < 0 or end > len(buffer) or start > end:
        raise ValueError("Invalid slice range")
    size = end - start
    return (c_ubyte * size)(*buffer[start:end])
##########################################################################
def buffer_to_ascii_string(buffer):
    """Convert an ASCII buffer to a string, replacing non-printable characters with '.'."""
    return ''.join(chr(b) if 32 <= b <= 126 else '.' for b in buffer)
##########################################################################

old_uid = (c_ubyte * 11)()
def isCardInField():
    
    uid = (c_ubyte * 11)()
    sak = c_ubyte()
    uid_size = c_ubyte()

    status = GetCardIdEx(sak, uid, uid_size)
    if (status == 0):
        uid_str = str()
        card_type = c_ubyte()

        same_card_in_field = True

        for n in range(uid_size.value):
            if (uid[n] != old_uid[n]):
                same_card_in_field = False
                break

        if (same_card_in_field):
            return False
        else:
            for n in range(uid_size.value):
                old_uid[n] = uid[n]

        for n in range(uid_size.value):
            uid_str += '%0.2x' % uid[n] + ':'
        
        status = GetDlogicCardType(card_type)

        if (status == 0) and (uid_size.value > 0):
            print("[ CARD_UID: " + uid_str.upper()[:-1] + " | CARD_TYPE: " + card_types.DLOGIC_CARD_TYPE[card_type.value] + " ]")
            return True
        else:
            memset(old_uid, 0, ctypes.sizeof(old_uid))
            return False
    else: 
        memset(old_uid, 0, ctypes.sizeof(old_uid))
        return False
##########################################################################
def char_to_code(char):
        return ord(char)
##########################################################################
def str_to_hex(string):
    return [ord(c) for c in string]
##########################################################################
# Convert the string back into a hex buffer
def string_to_hex_buffer(hex_string):
    if len(hex_string) % 2 != 0:
        raise ValueError("Hex string length must be even")
    return (c_ubyte * (len(hex_string) // 2))(
        *(int(hex_string[i:i+2], 16) for i in range(0, len(hex_string), 2))
    )
##########################################################################

def list_to_ascii_string(data_list):
    """
    Converts a list of integers to a string using ASCII mapping.
    
    :param data_list: List of integers representing ASCII values.
    :return: String decoded from ASCII values.
    """
    # Filter out zeros if they are not part of the intended output
    filtered_list = filter(lambda x: x != 0, data_list)
    return ''.join(map(chr, filtered_list))

def form_sdm_ndef_payload(url):
    # Initial NDEF payload setup
    ndef_with_header = [0x00, 0x00, 0xD1, 0x01, 0x00, 0x55, 0x00]
    ndef_header_len = len(ndef_with_header)
    total_ndef_len = 0

    # Parse URI and add to NDEF payload
    ndef_buffer = str_to_hex(url)
    ndef_with_header.extend(ndef_buffer)
    ndef_with_header.append(char_to_code('?'))
    total_ndef_len = len(ndef_with_header)
    print(total_ndef_len)

    uid_offset = 0
    read_ctr_offset = 0
    mac_offset = 0

    # add UID placeholder data to buffer
    ndef_with_header.extend([char_to_code(c) for c in "uid="])
    ndef_with_header.extend([0] * 14)
    uid_offset = total_ndef_len + 4
    total_ndef_len += 18
    #print("Total len after UID: ")
    #print(total_ndef_len)

    ndef_with_header.append(char_to_code('&'))
    ndef_with_header.extend([char_to_code(c) for c in "ctr="])
    ndef_with_header.extend([0] * 6)
    read_ctr_offset = total_ndef_len + 5
    total_ndef_len += 11
    #print("Total len after CTR: ")
    #print(total_ndef_len)
    
    # add SDM Counter placeholder data to buffer
    ndef_with_header.append(char_to_code('&'))
    ndef_with_header.extend([char_to_code(c) for c in "cmac="])
    ndef_with_header.extend([0] * 16)
    mac_offset = total_ndef_len + 6
    total_ndef_len += 22
    #print("Total len after CMAC: ")
    #print(total_ndef_len)

    # Update NDEF length fields in header bytes
    # ndef_with_header[1] = total ndef message length
    # ndef_with_header[4] = ndef record length
    ndef_with_header[1] = (total_ndef_len - ndef_header_len) + 5
    ndef_with_header[4] = (total_ndef_len - ndef_header_len) + 1

    #print(total_ndef_len)

    result = {}
    result["sdm_payload"] = ndef_with_header
    result["sdm_payload_length"] = total_ndef_len
    result["uid_offset"] = uid_offset
    result["read_ctr_offset"] = read_ctr_offset
    result["mac_offset"] = mac_offset

    return result

def add_additional_ndef_payload_parameter(sdm_payload, param_name, param_value):
    #print("Payload:", ", ".join(f"0x{byte:02X}" for byte in sdm_payload))
    ndef_message_length = sdm_payload[1]
    ndef_record_length = sdm_payload[4]

    #print("NDEF Message length", ndef_message_length)
    #print("NDEF Record length", ndef_record_length)
    if param_name or param_value:
        sdm_payload.append(char_to_code('&'))
        sdm_payload.extend([char_to_code(c) for c in param_name])
        sdm_payload.append(char_to_code('='))
        sdm_payload.extend([char_to_code(c) for c in param_value])

        extended_len = len(param_name) + len(param_value) + 2

        sdm_payload[1] = ndef_message_length + extended_len
        sdm_payload[4] = ndef_record_length + extended_len

    # Storing the result in a dictionary
    result = {}
    result["extended_payload"] = sdm_payload
    result["extended_payload_length"] = len(sdm_payload)

    return result
##########################################################################
if __name__ == '__main__':
    print("---------------------------------------------")
    print("https://www.d-logic.com/nfc-rfid-reader-sdk/")
    print("---------------------------------------------")
    print("NTAG424 DNA Programmer, version 1.0")
    print("---------------------------------------------")

    print("Trying to establish communication with the reader...")

    print(f"[DLL_VERSION = {GetDllVersionStr()}]")

    status = ReaderOpen()
    status_str = "ReaderOpen(): " + uFR_NT4H_Status2String(status)
    print(status_str)
    if (status != 0):
        exit(1)
    
    print("> PROGRAMMING BEGIN. ")

    print("> 1. Get card UID")
    uid = (c_ubyte * 11)()
    sak = c_ubyte()
    uid_size = c_ubyte()
    card_uid_str = str()

    status = GetCardIdEx(sak, uid, uid_size)
    if (status == 0):
        card_uid_str = uid_to_string(uid, uid_size)
        log_to_file(card_uid_str, f"Card UID successfully retrieved: {card_uid_str}")
    else:
        print("Failed to retrieve card UID. Exiting...")
        exit(1)
    
    print("> 2. Form SDM NDEF Payload...")
    uri = "http://by6od-j4aaa-aaaaa-qaadq-cai.localhost:4943/page1.html"
    formed_result = form_sdm_ndef_payload(uri)
    sdm_payload = formed_result["sdm_payload"]
    sdm_payload_length = formed_result["sdm_payload_length"]
    uid_offset = formed_result["uid_offset"]
    read_ctr_offset = formed_result["read_ctr_offset"]
    mac_offset = formed_result["mac_offset"]

    sdm_payload_str = buffer_to_ascii_string(sdm_payload)
    log_to_file(card_uid_str, f"    Payload [ASCII] = {sdm_payload_str}")

    print("> 3. Add additional parameter to NDEF outside of SDM")
    
    extended_payload_result = add_additional_ndef_payload_parameter(sdm_payload, "", "")

    extended_payload = extended_payload_result["extended_payload"]
    extended_payload_length = extended_payload_result["extended_payload_length"]
    log_to_file(card_uid_str, "Additional NDEF parameters added")

    print("> 4. Write SDM payload")
    file_no = c_ubyte(2)                # File number
    key_no = c_ubyte(0)                 # Write key no
    communication_mode = c_ubyte(0)     # Communication mode
    status = nt4h_set_global_parameters(file_no, key_no, communication_mode)

    default_aes_key = (c_ubyte * 16)()
    memset(default_aes_key, 0, ctypes.sizeof(default_aes_key))
    write_data_buffer = (c_ubyte * len(extended_payload))(*extended_payload)
    write_len = c_uint16(extended_payload_length)
    bytes_written = c_uint16()
    auth_mode = c_ubyte(T4T_AUTHENTICATION["T4T_PK_PWD_AUTH"])
    
    status = LinearWrite_PK(write_data_buffer, 0, write_len, bytes_written, auth_mode, default_aes_key)
    if (status == 0):
        log_to_file(card_uid_str, "NDEF Message written successfully")
    else:
        log_to_file(card_uid_str, "Failed to write NDEF message", status)
        exit(1)

    print("> 5. Change SDM settings")
    communication_mode = c_ubyte(3)
    new_communication_mode = c_ubyte(0)

    read_key_no = c_ubyte(0x0E)
    write_key_no = c_ubyte(0)
    read_write_key_no = c_ubyte(0)
    change_key_no = c_ubyte(0)

    uid_enable = c_ubyte(1)
    read_ctr_enable = c_ubyte(1)
    read_ctr_limit_enable = c_ubyte(0)
    enc_file_data_enable = c_ubyte(0)

    meta_data_key_no = c_ubyte(0x0E)
    file_data_read_key_no = c_ubyte(0)
    read_ctr_key_no = c_ubyte(0)

    picc_data_offset = c_uint(0)
    mac_input_offset = c_uint(mac_offset)
    enc_offset = c_uint(0)
    enc_length = c_uint(0)
    read_ctr_limit = c_uint(0)

    tt_status_enable = c_ubyte(0)
    tt_status_offset = c_uint(0)

    status = nt4h_tt_change_sdm_file_settings_pk(default_aes_key, file_no, key_no, communication_mode, new_communication_mode, 
                            read_key_no, write_key_no, read_write_key_no, change_key_no,
                            uid_enable, read_ctr_enable, read_ctr_limit_enable, enc_file_data_enable,
                            meta_data_key_no, file_data_read_key_no, read_ctr_key_no,
                            uid_offset, read_ctr_offset, picc_data_offset, mac_input_offset,
                            enc_offset, enc_length, mac_offset, read_ctr_limit, 
                            tt_status_enable, tt_status_offset)
    if (status == 0):
        log_to_file(card_uid_str, "SDM settings set successfully")
    else:
        log_to_file(card_uid_str, "Failed to set SDM settings", status)
        exit(1)

    """
    print(">>>> Try reading data...")
    if (status == 0):
        log_to_file(card_uid_str, "SDM data verified successfully")
    else:
        log_to_file(card_uid_str, "Failed to verify SDM data", status)
        exit(1)
    """
    
    # print("6. Change Master key")
    # new_aes_key_str = generate_random_aes_key_hex()
    # #print(f"Randomized key is: {new_aes_key_str}")
    # new_aes_key = string_to_hex_buffer(new_aes_key_str)
    
    # status = nt4h_change_key_pk(default_aes_key, 0, new_aes_key, default_aes_key)
    # if (status == 0):
    #     log_to_file(card_uid_str, f"Card master key changed successfully to: {new_aes_key_str}")
    # else:
    #     log_to_file(card_uid_str, "Failed to change card master key", status)
    #     exit(1)
    
    ReaderClose()

================
File: scripts/setup_route.py
================
#!/usr/bin/env python3
import subprocess
import argparse
import json
from typing import Optional, Tuple
from ctypes import c_ubyte, c_uint, c_uint16, byref, memset, sizeof
import ntag424_programmer as ntp

def get_canister_name_from_dfx() -> Optional[str]:
    """Read dfx.json and get the canister name."""
    try:
        with open('dfx.json', 'r') as f:
            dfx_config = json.load(f)
            for canister_name in dfx_config.get('canisters', {}):
                if canister_name != 'internet_identity':
                    return canister_name
        return None
    except Exception as e:
        print(f"Error reading dfx.json: {str(e)}")
        return None

def run_command(command: str) -> Tuple[int, str, str]:
    """Run a shell command and return its exit code, stdout, and stderr."""
    process = subprocess.Popen(
        command,
        shell=True,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True
    )
    stdout, stderr = process.communicate()
    return process.returncode, stdout, stderr

def setup_route_and_program(canister_id: str, page: str, params: str = None, use_random_key: bool = False, ic_mode: bool = False) -> bool:
    """Setup protected route and program NFC card."""
    try:
        # Get canister name from dfx.json
        canister_name = get_canister_name_from_dfx()
        if not canister_name:
            print("Error: Could not find canister name in dfx.json")
            return False
        print(f"Using canister name from dfx.json: {canister_name}")

        # Form the URI for the card based on environment
        if ic_mode:
            uri = f"https://{canister_id}.raw.icp0.io/{page}"
        else:
            uri = f"http://{canister_id}.localhost:4943/{page}"
        print(f"Using URI: {uri}")

        # Start card programming following ntag424_programmer.py logic
        status = ntp.ReaderOpen()
        if status != 0:
            print(f"Error opening reader: {ntp.uFR_NT4H_Status2String(status)}")
            return False

        # Get card UID (following ntag424_programmer.py logic)
        uid = (c_ubyte * 11)()
        sak = c_ubyte()
        uid_size = c_ubyte()
        status = ntp.GetCardIdEx(sak, uid, uid_size)
        if status != 0:
            print(f"Error getting card ID: {ntp.uFR_NT4H_Status2String(status)}")
            return False
            
        card_uid = ''.join(f'{uid[n]:02X}' for n in range(uid_size.value))
        print(f"Successfully got card UID: {card_uid}")

        # Form SDM NDEF Payload
        formed_result = ntp.form_sdm_ndef_payload(uri)
        print(f"Formed NDEF payload")

        # Get extended payload
        extended_payload_result = ntp.add_additional_ndef_payload_parameter(
            formed_result["sdm_payload"],
            params.split('=')[0] if params and '=' in params else "",
            params.split('=')[1] if params and '=' in params else ""
        )

        # Setup for writing
        default_key = (c_ubyte * 16)()
        memset(default_key, 0, sizeof(default_key))

        # Write SDM payload
        file_no = c_ubyte(2)
        key_no = c_ubyte(0)
        communication_mode = c_ubyte(0)
        status = ntp.nt4h_set_global_parameters(file_no, key_no, communication_mode)
        if status != 0:
            print(f"Error setting global parameters: {ntp.uFR_NT4H_Status2String(status)}")
            return False

        write_data_buffer = (c_ubyte * len(extended_payload_result["extended_payload"]))(*extended_payload_result["extended_payload"])
        write_len = c_uint16(extended_payload_result["extended_payload_length"])
        bytes_written = c_uint16()
        auth_mode = c_ubyte(ntp.T4T_AUTHENTICATION["T4T_PK_PWD_AUTH"])

        status = ntp.LinearWrite_PK(write_data_buffer, 0, write_len, bytes_written, auth_mode, default_key)
        if status != 0:
            print(f"Error writing NDEF message: {ntp.uFR_NT4H_Status2String(status)}")
            return False
        print("NDEF Message written successfully")

        # Change SDM settings
        communication_mode = c_ubyte(3)
        new_communication_mode = c_ubyte(0)
        read_key_no = c_ubyte(0x0E)
        write_key_no = c_ubyte(0)
        read_write_key_no = c_ubyte(0)
        change_key_no = c_ubyte(0)
        uid_enable = c_ubyte(1)
        read_ctr_enable = c_ubyte(1)
        read_ctr_limit_enable = c_ubyte(0)
        enc_file_data_enable = c_ubyte(0)
        meta_data_key_no = c_ubyte(0x0E)
        file_data_read_key_no = c_ubyte(0)
        read_ctr_key_no = c_ubyte(0)
        picc_data_offset = c_uint(0)
        mac_input_offset = c_uint(formed_result["mac_offset"])
        enc_offset = c_uint(0)
        enc_length = c_uint(0)
        read_ctr_limit = c_uint(0)
        tt_status_enable = c_ubyte(0)
        tt_status_offset = c_uint(0)

        status = ntp.nt4h_tt_change_sdm_file_settings_pk(
            default_key, file_no, key_no, communication_mode, new_communication_mode,
            read_key_no, write_key_no, read_write_key_no, change_key_no,
            uid_enable, read_ctr_enable, read_ctr_limit_enable, enc_file_data_enable,
            meta_data_key_no, file_data_read_key_no, read_ctr_key_no,
            formed_result["uid_offset"], formed_result["read_ctr_offset"], 
            picc_data_offset, mac_input_offset,
            enc_offset, enc_length, formed_result["mac_offset"], read_ctr_limit,
            tt_status_enable, tt_status_offset
        )
        if status != 0:
            print(f"Error setting SDM settings: {ntp.uFR_NT4H_Status2String(status)}")
            return False
        print("SDM settings set successfully")

        if use_random_key:
            new_key_str = ntp.generate_random_aes_key_hex()
            new_key = ntp.string_to_hex_buffer(new_key_str)
            status = ntp.nt4h_change_key_pk(default_key, 0, new_key, default_key)
            if status != 0:
                print(f"Error changing master key: {ntp.uFR_NT4H_Status2String(status)}")
                return False
            print(f"Master key changed successfully to: {new_key_str}")
            cmd = f'python3 scripts/hashed_cmacs.py -k {new_key_str} -u {card_uid} -c 50 -o cmacs.json'
        else:
            # Generate CMACs with default key
            cmd = f'python3 scripts/hashed_cmacs.py -k 00000000000000000000000000000000 -u {card_uid} -c 50 -o cmacs.json'
        exit_code, stdout, stderr = run_command(cmd)
        if exit_code != 0:
            print(f"Error generating CMACs: {stderr}")
            return False
        print("Generated CMACs successfully")

        # Add --ic flag to dfx calls when in IC mode
        ic_flag = "--ic " if ic_mode else ""
        
        cmd = f'dfx canister call {ic_flag}{canister_name} add_protected_route \'("{page}")\''
        exit_code, stdout, stderr = run_command(cmd)
        if exit_code != 0:
            print(f"Error adding protected route: {stderr}")
            return False
        print("Added protected route successfully")

        # Pass the ic_mode flag to batch_cmacs.py
        ic_flag_param = "--ic" if ic_mode else ""
        cmd = f'python3 scripts/batch_cmacs.py cmacs.json {canister_name} {page} {ic_flag_param}'
        exit_code, stdout, stderr = run_command(cmd)
        if exit_code != 0:
            print(f"Error uploading CMACs: {stderr}")
            return False
        print("Uploaded CMACs successfully")

        return True

    except Exception as e:
        print(f"An error occurred: {str(e)}")
        return False
    finally:
        ntp.ReaderClose()

def main():
    parser = argparse.ArgumentParser(description='Program NFC card and set up protected route')
    parser.add_argument('canister_id', help='The canister ID')
    parser.add_argument('page', help='The page to protect (e.g., page1.html)')
    parser.add_argument('--random-key', action='store_true', 
                       help='Generate and use a random key instead of default')
    parser.add_argument('--params', help='Additional query parameters (e.g., param1=value1)')
    parser.add_argument('--ic', action='store_true',
                       help='Use IC production mode (connects to ICP network instead of local replica)')
    
    args = parser.parse_args()
    
    if setup_route_and_program(args.canister_id, args.page, args.params, args.random_key, args.ic):
        print("\nSetup completed successfully!")
    else:
        print("\nSetup failed!")

if __name__ == "__main__":
    main()

================
File: src/backend/main.mo
================
import Text "mo:base/Text";
import Nat "mo:base/Nat";
import Cycles "mo:base/ExperimentalCycles";
import Principal "mo:base/Principal";
import Routes "routes";
// import Blob "mo:base/Blob";
import Option "mo:base/Option";

shared ({ caller = creator }) actor class () = this {

  stable let routesState = Routes.init();
  let routes_storage = Routes.RoutesStorage(routesState);

  public shared ({ caller }) func add_protected_route(path : Text) : async () {
    assert (caller == creator);
    ignore routes_storage.addProtectedRoute(path);
  };

  public shared ({ caller }) func update_route_cmacs(path : Text, new_cmacs : [Text]) : async () {
    assert (caller == creator);
    ignore routes_storage.updateRouteCmacs(path, new_cmacs);
  };

  public shared ({ caller }) func append_route_cmacs(path : Text, new_cmacs : [Text]) : async () {
    assert (caller == creator);
    ignore routes_storage.appendRouteCmacs(path, new_cmacs);
  };

  public query func get_route_protection(path : Text) : async ?Routes.ProtectedRoute {
    routes_storage.getRoute(path);
  };

  public query func get_route_cmacs(path : Text) : async [Text] {
    routes_storage.getRouteCmacs(path);
  };

  public query ({ caller }) func whoAmI() : async Principal {
    return caller;
  };

  public query func get_cycle_balance() : async Nat {
    return Cycles.balance();
  };

 
 
  // public query func validate_url_scan(url : Text, path : Text) : async Bool {
  //     // Check each protected route
  //   let routes_array = routes_storage.listProtectedRoutes();
  //   for ((path, protection) in routes_array.vals()) {
  //     if (Text.contains(url, #text path)) {
  //       let hasAccess = routes_storage.verifyRouteAccess(path, req.url);
  //       let new_request = {
  //         url = if (hasAccess) {
  //           return true
  //         } else {
  //           return false // 
  //         };
        
  //     };
  //   };
  // };

   public query func validate_url_scan(url : Text, path : Text) : async Bool {
    // First, check if the path is protected
    switch (routes_storage.getRoute(path)) {
      case (null) {
        // If path is not protected, return true (access allowed)
        return true;
      };
      case (_) {
        // Path is protected, verify scan parameters
        return routes_storage.verifyRouteAccess(path, url);
      };
    };
  };

  public query func is_protected_route(path : Text) : async Bool {
    Option.isSome(routes_storage.getRoute(path));
  };


  };

================
File: src/backend/routes.mo
================
import Text "mo:base/Text";
import HashMap "mo:base/HashMap";
import Iter "mo:base/Iter";
import Array "mo:base/Array";
import Option "mo:base/Option";
import Scan "scan";

module {
    public type ProtectedRoute = {
        path : Text;
        cmacs_ : [Text];
        scan_count_ : Nat;
    };

    public type State = {
        var protected_routes : [(Text, ProtectedRoute)];
    };

    public func init() : State = {
        var protected_routes = [];
    };

    public class RoutesStorage(state : State) {
        private var routes = HashMap.fromIter<Text, ProtectedRoute>(
            state.protected_routes.vals(),
            state.protected_routes.size(),
            Text.equal,
            Text.hash,
        );

        public func addProtectedRoute(path : Text) : Bool {
            if (Option.isNull(routes.get(path))) {
                let new_route : ProtectedRoute = {
                    path;
                    cmacs_ = [];
                    scan_count_ = 0;
                };
                routes.put(path, new_route);
                updateState();
                true;
            } else {
                false;
            };
        };

        public func updateRouteCmacs(path : Text, new_cmacs : [Text]) : Bool {
            switch (routes.get(path)) {
                case (?existing) {
                    routes.put(
                        path,
                        {
                            path = existing.path;
                            cmacs_ = new_cmacs;
                            scan_count_ = existing.scan_count_;
                        },
                    );
                    updateState();
                    true;
                };
                case null {
                    false;
                };
            };
        };

        public func appendRouteCmacs(path : Text, new_cmacs : [Text]) : Bool {
            switch (routes.get(path)) {
                case (?existing) {
                    routes.put(
                        path,
                        {
                            path = existing.path;
                            cmacs_ = Array.append(existing.cmacs_, new_cmacs);
                            scan_count_ = existing.scan_count_;
                        },
                    );
                    updateState();
                    true;
                };
                case null {
                    false;
                };
            };
        };

        public func getRoute(path : Text) : ?ProtectedRoute {
            routes.get(path);
        };

        public func getRouteCmacs(path : Text) : [Text] {
            switch (routes.get(path)) {
                case (?route) {
                    route.cmacs_;
                };
                case null { [] };
            };
        };

        public func updateScanCount(path : Text, new_count : Nat) : Bool {
            switch (routes.get(path)) {
                case (?existing) {
                    routes.put(
                        path,
                        {
                            path = existing.path;
                            cmacs_ = existing.cmacs_;
                            scan_count_ = new_count;
                        },
                    );
                    updateState();
                    true;
                };
                case null {
                    false;
                };
            };
        };

        public func verifyRouteAccess(path : Text, url : Text) : Bool {
            switch (routes.get(path)) {
                case (?route) {
                    let counter = Scan.scan(route.cmacs_, url, route.scan_count_);
                    if (counter > 0) {
                        ignore updateScanCount(path, counter);
                        true;
                    } else {
                        false;
                    };
                };
                case null {
                    false;
                };
            };
        };

        public func listProtectedRoutes() : [(Text, ProtectedRoute)] {
            Iter.toArray(routes.entries());
        };

        public func isProtectedRoute(url : Text) : Bool {
            Option.isSome(Array.find<(Text, ProtectedRoute)>(
                Iter.toArray(routes.entries()),
                func((path, _)) : Bool {
                    Text.contains(url, #text path);
                },
            ));
        };

        private func updateState() {
            state.protected_routes := Iter.toArray(routes.entries());
        };

        public func getState() : State {
            state;
        };
    };
};

================
File: src/backend/scan.mo
================
import Text "mo:base/Text";
import Nat "mo:base/Nat";
import Array "mo:base/Array";
import Iter "mo:base/Iter";
import Char "mo:base/Char";
import Nat8 "mo:base/Nat8";
import Nat32 "mo:base/Nat32";
import Sha "sha";

module {
    public func hexToNat(hexString: Text) : Nat {
        var result : Nat = 0;
        for (char in Text.toIter(hexString)) {
            if (Char.toNat32(char) >= Char.toNat32('0') and Char.toNat32(char) <= Char.toNat32( '9')) {
                result := result * 16 + (Nat32.toNat(Char.toNat32(char)) - 48);
            }
            else if (Char.toNat32(char) >= Char.toNat32('A') and Char.toNat32(char) <= Char.toNat32( 'F')) {
                result := result * 16 + (Nat32.toNat(Char.toNat32(char)) - 55);
            }
            else if (Char.toNat32(char) >= Char.toNat32('a') and Char.toNat32(char) <= Char.toNat32('f')) {
                result := result * 16 + (Nat32.toNat(Char.toNat32(char)) - 87);
            }
            else {
                assert(false);
            }
        };
        return result;
    };

    public func subText(value : Text, indexStart : Nat, indexEnd : Nat) : Text {
        if (indexStart == 0 and indexEnd >= value.size()) {
            return value;
        }
        else if (indexStart >= value.size()) {
            return "";
        };
        
        var indexEndValid = indexEnd;
        if (indexEnd > value.size()) {
            indexEndValid := value.size();
        };

        var result : Text = "";
        var iter = Iter.toArray<Char>(Text.toIter(value));
        for (index in Iter.range(indexStart, indexEndValid - 1)) {
            result := result # Char.toText(iter[index]);
        };

        result;
    };

    public func scan(cmacs: [Text], url : Text, scan_count : Nat) : Nat {
        let full_query = Iter.toArray(Text.split(url, #char '?'));
        if (full_query.size() != 2) {
            return 0;
        };

        let queries = Iter.toArray(Text.split(full_query[1], #char '&'));

        // if (queries.size() != 3) {
        //     return 0;
        // };

        if (queries.size() != 3 and queries.size() != 4) {
             return 0;
        };

        let cmac_query = Iter.toArray(Text.split(queries[2], #char '='));
        let counter_query = Iter.toArray(Text.split(queries[1], #char '='));

        if (cmac_query.size() != 2 or counter_query.size() != 2 or cmac_query[0] != "cmac" or counter_query[0] != "ctr") {
            return 0;
        };
        
        var counter = hexToNat(counter_query[1]);

        let sha = Sha.sha256(Array.map(Text.toArray(cmac_query[1]), func (c : Char) : Nat8 { 
            Nat8.fromNat(Nat32.toNat(Char.toNat32(c)))
        }));
    
        if (counter >= cmacs.size() or counter <= scan_count) {
            return 0;
        };

        var res = counter;

        for (i in Iter.range(0, sha.size() - 1)) {
            if (Nat8.toNat(sha[i]) != hexToNat(subText(cmacs[counter - 1], i * 2, i * 2 + 2))) {
                res := 0;
            };
        };
   
        return res;
    };
}

================
File: src/backend/sha.mo
================
/**
 * Module      : SHA256.mo
 * Description : Cryptographic hash function.
 * Copyright   : 2020 DFINITY Stiftung
 * License     : Apache 2.0 with LLVM Exception
 * Maintainer  : Enzo Haussecker <enzo@dfinity.org>
 * Stability   : Stable
 */

import Array "mo:base/Array";
import Iter "mo:base/Iter";
import Nat "mo:base/Nat";
import Nat8 "mo:base/Nat8";
import Nat32 "mo:base/Nat32";
import Nat64 "mo:base/Nat64";

module {

  private let K : [Nat32] = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
    0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
    0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
    0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
    0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
    0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
    0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
    0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
    0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,
  ];

  private let S : [Nat32] = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,
  ];

  // Calculate a SHA256 hash.
  public func sha256(data : [Nat8]) : [Nat8] {
    let digest = Digest();
    digest.write(data);
    return digest.sum();
  };

  public class Digest() {

    private let s = Array.thaw<Nat32>(S);

    private let x = Array.init<Nat8>(64, 0);

    private var nx = 0;

    private var len : Nat64 = 0;

    public func reset() {
      for (i in Iter.range(0, 7)) {
        s[i] := S[i];
      };
      nx := 0;
      len := 0;
    };

    public func write(data : [Nat8]) {
      var p = data;
      len +%= Nat64.fromIntWrap(p.size());
      if (nx > 0) {
        let n = Nat.min(p.size(), 64 - nx);
        for (i in Iter.range(0, n - 1)) {
          x[nx + i] := p[i];
        };
        nx += n;
        if (nx == 64) {
          let buf = Array.freeze<Nat8>(x);
          block(buf);
          nx := 0;
        };
        p := Array.tabulate<Nat8>(p.size() - n, func (i) {
          return p[n + i];
        });
      };
      if (p.size() >= 64) {
        let n = Nat64.toNat(Nat64.fromIntWrap(p.size()) & (^ 63));
        let buf = Array.tabulate<Nat8>(n, func (i) {
          return p[i];
        });
        block(buf);
        p := Array.tabulate<Nat8>(p.size() - n, func (i) {
          return p[n + i];
        });
      };
      if (p.size() > 0) {
        for (i in Iter.range(0, p.size() - 1)) {
          x[i] := p[i];
        };
        nx := p.size();
      };
    };

    public func sum() : [Nat8] {
      var m = 0;
      var n = len;
      var t = Nat64.toNat(n) % 64;
      var buf : [var Nat8] = [var];
      if (56 > t) {
        m := 56 - t;
      } else {
        m := 120 - t;
      };
      n := n << 3;
      buf := Array.init<Nat8>(m, 0);
      if (m > 0) {
        buf[0] := 0x80;
      };
      write(Array.freeze<Nat8>(buf));
      buf := Array.init<Nat8>(8, 0);
      for (i in Iter.range(0, 7)) {
        let j : Nat64 = 56 -% 8 *% Nat64.fromIntWrap(i);
        buf[i] := Nat8.fromIntWrap(Nat64.toNat(n >> j));
      };
      write(Array.freeze<Nat8>(buf));
      let hash = Array.init<Nat8>(32, 0);
      for (i in Iter.range(0, 7)) {
        for (j in Iter.range(0, 3)) {
          let k : Nat32 = 24 -% 8 *% Nat32.fromIntWrap(j);
          hash[4 * i + j] := Nat8.fromIntWrap(Nat32.toNat(s[i] >> k));
        };
      };
      return Array.freeze<Nat8>(hash);
    };

    private func block(data : [Nat8]) {
      var p = data;
      var w = Array.init<Nat32>(64, 0);
      while (p.size() >= 64) {
        var j = 0;
        for (i in Iter.range(0, 15)) {
          j := i * 4;
          w[i] :=
            Nat32.fromIntWrap(Nat8.toNat(p[j + 0])) << 24 |
            Nat32.fromIntWrap(Nat8.toNat(p[j + 1])) << 16 |
            Nat32.fromIntWrap(Nat8.toNat(p[j + 2])) << 08 |
            Nat32.fromIntWrap(Nat8.toNat(p[j + 3])) << 00;
        };
        var v1 : Nat32 = 0;
        var v2 : Nat32 = 0;
        var t1 : Nat32 = 0;
        var t2 : Nat32 = 0;
        for (i in Iter.range(16, 63)) {
          v1 := w[i - 02];
          v2 := w[i - 15];
          t1 := rot(v1, 17) ^ rot(v1, 19) ^ (v1 >> 10);
          t2 := rot(v2, 07) ^ rot(v2, 18) ^ (v2 >> 03);
          w[i] :=
              t1 +% w[i - 07] +%
              t2 +% w[i - 16];
        };
        var a = s[0];
        var b = s[1];
        var c = s[2];
        var d = s[3];
        var e = s[4];
        var f = s[5];
        var g = s[6];
        var h = s[7];
        for (i in Iter.range(0, 63)) {
          t1 := rot(e, 06) ^ rot(e, 11) ^ rot(e, 25);
          t1 +%= (e & f) ^ (^ e & g) +% h +% K[i] +% w[i];
          t2 := rot(a, 02) ^ rot(a, 13) ^ rot(a, 22);
          t2 +%= (a & b) ^ (a & c) ^ (b & c);
          h := g;
          g := f;
          f := e;
          e := d +% t1;
          d := c;
          c := b;
          b := a;
          a := t1 +% t2;
        };
        s[0] +%= a;
        s[1] +%= b;
        s[2] +%= c;
        s[3] +%= d;
        s[4] +%= e;
        s[5] +%= f;
        s[6] +%= g;
        s[7] +%= h;
        p := Array.tabulate<Nat8>(p.size() - 64, func (i) {
          return p[i + 64];
        });
      };
    };
  };

  private let rot : (Nat32, Nat32) -> Nat32 = Nat32.bitrotRight;
};

================
File: src/declarations/backend/backend.did
================
type _anon_class_10_1 = 
 service {
   add_protected_route: (text) -> ();
   append_route_cmacs: (text, vec text) -> ();
   get_cycle_balance: () -> (nat) query;
   get_route_cmacs: (text) -> (vec text) query;
   get_route_protection: (text) -> (opt ProtectedRoute) query;
   is_protected_route: (text) -> (bool) query;
   update_route_cmacs: (text, vec text) -> ();
   validate_url_scan: (text, text) -> (bool) query;
   whoAmI: () -> (principal) query;
 };
type ProtectedRoute = 
 record {
   cmacs: vec text;
   path: text;
   scan_count: nat;
 };
service : () -> _anon_class_10_1

================
File: src/declarations/backend/backend.did.d.ts
================
import type { Principal } from '@dfinity/principal';
import type { ActorMethod } from '@dfinity/agent';
import type { IDL } from '@dfinity/candid';

export interface ProtectedRoute {
  'cmacs' : Array<string>,
  'path' : string,
  'scan_count' : bigint,
}
export interface _anon_class_10_1 {
  'add_protected_route' : ActorMethod<[string], undefined>,
  'append_route_cmacs' : ActorMethod<[string, Array<string>], undefined>,
  'get_cycle_balance' : ActorMethod<[], bigint>,
  'get_route_cmacs' : ActorMethod<[string], Array<string>>,
  'get_route_protection' : ActorMethod<[string], [] | [ProtectedRoute]>,
  'is_protected_route' : ActorMethod<[string], boolean>,
  'update_route_cmacs' : ActorMethod<[string, Array<string>], undefined>,
  'validate_url_scan' : ActorMethod<[string, string], boolean>,
  'whoAmI' : ActorMethod<[], Principal>,
}
export interface _SERVICE extends _anon_class_10_1 {}
export declare const idlFactory: IDL.InterfaceFactory;
export declare const init: (args: { IDL: typeof IDL }) => IDL.Type[];

================
File: src/declarations/backend/backend.did.js
================
export const idlFactory = ({ IDL }) => {
  const ProtectedRoute = IDL.Record({
    'cmacs' : IDL.Vec(IDL.Text),
    'path' : IDL.Text,
    'scan_count' : IDL.Nat,
  });
  const _anon_class_10_1 = IDL.Service({
    'add_protected_route' : IDL.Func([IDL.Text], [], []),
    'append_route_cmacs' : IDL.Func([IDL.Text, IDL.Vec(IDL.Text)], [], []),
    'get_cycle_balance' : IDL.Func([], [IDL.Nat], ['query']),
    'get_route_cmacs' : IDL.Func([IDL.Text], [IDL.Vec(IDL.Text)], ['query']),
    'get_route_protection' : IDL.Func(
        [IDL.Text],
        [IDL.Opt(ProtectedRoute)],
        ['query'],
      ),
    'is_protected_route' : IDL.Func([IDL.Text], [IDL.Bool], ['query']),
    'update_route_cmacs' : IDL.Func([IDL.Text, IDL.Vec(IDL.Text)], [], []),
    'validate_url_scan' : IDL.Func([IDL.Text, IDL.Text], [IDL.Bool], ['query']),
    'whoAmI' : IDL.Func([], [IDL.Principal], ['query']),
  });
  return _anon_class_10_1;
};
export const init = ({ IDL }) => { return []; };

================
File: src/declarations/backend/index.d.ts
================
import type {
  ActorSubclass,
  HttpAgentOptions,
  ActorConfig,
  Agent,
} from "@dfinity/agent";
import type { Principal } from "@dfinity/principal";
import type { IDL } from "@dfinity/candid";

import { _SERVICE } from './backend.did';

export declare const idlFactory: IDL.InterfaceFactory;
export declare const canisterId: string;

export declare interface CreateActorOptions {
  /**
   * @see {@link Agent}
   */
  agent?: Agent;
  /**
   * @see {@link HttpAgentOptions}
   */
  agentOptions?: HttpAgentOptions;
  /**
   * @see {@link ActorConfig}
   */
  actorOptions?: ActorConfig;
}

/**
 * Intializes an {@link ActorSubclass}, configured with the provided SERVICE interface of a canister.
 * @constructs {@link ActorSubClass}
 * @param {string | Principal} canisterId - ID of the canister the {@link Actor} will talk to
 * @param {CreateActorOptions} options - see {@link CreateActorOptions}
 * @param {CreateActorOptions["agent"]} options.agent - a pre-configured agent you'd like to use. Supercedes agentOptions
 * @param {CreateActorOptions["agentOptions"]} options.agentOptions - options to set up a new agent
 * @see {@link HttpAgentOptions}
 * @param {CreateActorOptions["actorOptions"]} options.actorOptions - options for the Actor
 * @see {@link ActorConfig}
 */
export declare const createActor: (
  canisterId: string | Principal,
  options?: CreateActorOptions
) => ActorSubclass<_SERVICE>;

/**
 * Intialized Actor using default settings, ready to talk to a canister using its candid interface
 * @constructs {@link ActorSubClass}
 */
export declare const backend: ActorSubclass<_SERVICE>;

================
File: src/declarations/backend/index.js
================
import { Actor, HttpAgent } from "@dfinity/agent";

// Imports and re-exports candid interface
import { idlFactory } from "./backend.did.js";
export { idlFactory } from "./backend.did.js";

/* CANISTER_ID is replaced by webpack based on node environment
 * Note: canister environment variable will be standardized as
 * process.env.CANISTER_ID_<CANISTER_NAME_UPPERCASE>
 * beginning in dfx 0.15.0
 */
export const canisterId =
  process.env.CANISTER_ID_BACKEND;

export const createActor = (canisterId, options = {}) => {
  const agent = options.agent || new HttpAgent({ ...options.agentOptions });

  if (options.agent && options.agentOptions) {
    console.warn(
      "Detected both agent and agentOptions passed to createActor. Ignoring agentOptions and proceeding with the provided agent."
    );
  }

  // Fetch root key for certificate validation during development
  if (process.env.DFX_NETWORK !== "ic") {
    agent.fetchRootKey().catch((err) => {
      console.warn(
        "Unable to fetch root key. Check to ensure that your local replica is running"
      );
      console.error(err);
    });
  }

  // Creates an actor with using the candid interface and the HttpAgent
  return Actor.createActor(idlFactory, {
    agent,
    canisterId,
    ...options.actorOptions,
  });
};

export const backend = canisterId ? createActor(canisterId) : undefined;

================
File: src/declarations/frontend/frontend.did
================
type BatchId = nat;
type ChunkId = nat;
type Key = text;
type Time = int;

type CreateAssetArguments = record {
  key: Key;
  content_type: text;
  max_age: opt nat64;
  headers: opt vec HeaderField;
  enable_aliasing: opt bool;
  allow_raw_access: opt bool;
};

// Add or change content for an asset, by content encoding
type SetAssetContentArguments = record {
  key: Key;
  content_encoding: text;
  chunk_ids: vec ChunkId;
  sha256: opt blob;
};

// Remove content for an asset, by content encoding
type UnsetAssetContentArguments = record {
  key: Key;
  content_encoding: text;
};

// Delete an asset
type DeleteAssetArguments = record {
  key: Key;
};

// Reset everything
type ClearArguments = record {};

type BatchOperationKind = variant {
  CreateAsset: CreateAssetArguments;
  SetAssetContent: SetAssetContentArguments;

  SetAssetProperties: SetAssetPropertiesArguments;

  UnsetAssetContent: UnsetAssetContentArguments;
  DeleteAsset: DeleteAssetArguments;

  Clear: ClearArguments;
};

type CommitBatchArguments = record {
  batch_id: BatchId;
  operations: vec BatchOperationKind
};

type CommitProposedBatchArguments = record {
  batch_id: BatchId;
  evidence: blob;
};

type ComputeEvidenceArguments = record {
  batch_id: BatchId;
  max_iterations: opt nat16
};

type DeleteBatchArguments = record {
  batch_id: BatchId;
};

type HeaderField = record { text; text; };

type HttpRequest = record {
  method: text;
  url: text;
  headers: vec HeaderField;
  body: blob;
  certificate_version: opt nat16;
};

type HttpResponse = record {
  status_code: nat16;
  headers: vec HeaderField;
  body: blob;
  streaming_strategy: opt StreamingStrategy;
};

type StreamingCallbackHttpResponse = record {
  body: blob;
  token: opt StreamingCallbackToken;
};

type StreamingCallbackToken = record {
  key: Key;
  content_encoding: text;
  index: nat;
  sha256: opt blob;
};

type StreamingStrategy = variant {
  Callback: record {
    callback: func (StreamingCallbackToken) -> (opt StreamingCallbackHttpResponse) query;
    token: StreamingCallbackToken;
  };
};

type SetAssetPropertiesArguments = record {
  key: Key;
  max_age: opt opt nat64;
  headers: opt opt vec HeaderField;
  allow_raw_access: opt opt bool;
  is_aliased: opt opt bool;
};

type ConfigurationResponse = record {
  max_batches: opt nat64;
  max_chunks: opt nat64;
  max_bytes: opt nat64;
};

type ConfigureArguments = record {
  max_batches: opt opt nat64;
  max_chunks: opt opt nat64;
  max_bytes: opt opt nat64;
};

type Permission = variant {
  Commit;
  ManagePermissions;
  Prepare;
};

type GrantPermission = record {
  to_principal: principal;
  permission: Permission;
};
type RevokePermission = record {
  of_principal: principal;
  permission: Permission;
};
type ListPermitted = record { permission: Permission };

type ValidationResult = variant { Ok : text; Err : text };

type AssetCanisterArgs = variant {
  Init: InitArgs;
  Upgrade: UpgradeArgs;
};

type InitArgs = record {
  set_permissions: opt SetPermissions;
};

type UpgradeArgs = record {
  set_permissions: opt SetPermissions;
};

/// Sets the list of principals granted each permission.
type SetPermissions = record {
  prepare: vec principal;
  commit: vec principal;
  manage_permissions: vec principal;
};

service: (asset_canister_args: opt AssetCanisterArgs) -> {
  api_version: () -> (nat16) query;

  get: (record {
    key: Key;
    accept_encodings: vec text;
  }) -> (record {
    content: blob; // may be the entirety of the content, or just chunk index 0
    content_type: text;
    content_encoding: text;
    sha256: opt blob; // sha256 of entire asset encoding, calculated by dfx and passed in SetAssetContentArguments
    total_length: nat; // all chunks except last have size == content.size()
  }) query;

  // if get() returned chunks > 1, call this to retrieve them.
  // chunks may or may not be split up at the same boundaries as presented to create_chunk().
  get_chunk: (record {
    key: Key;
    content_encoding: text;
    index: nat;
    sha256: opt blob;  // sha256 of entire asset encoding, calculated by dfx and passed in SetAssetContentArguments
  }) -> (record { content: blob }) query;

  list : (record {}) -> (vec record {
    key: Key;
    content_type: text;
    encodings: vec record {
      content_encoding: text;
      sha256: opt blob; // sha256 of entire asset encoding, calculated by dfx and passed in SetAssetContentArguments
      length: nat; // Size of this encoding's blob. Calculated when uploading assets.
      modified: Time;
    };
  }) query;

  certified_tree : (record {}) -> (record {
    certificate: blob;
    tree: blob;
  }) query;

  create_batch : (record {}) -> (record { batch_id: BatchId });

  create_chunk: (record { batch_id: BatchId; content: blob }) -> (record { chunk_id: ChunkId });
  create_chunks: (record { batch_id: BatchId; content: vec blob }) -> (record { chunk_ids: vec ChunkId });

  // Perform all operations successfully, or reject
  commit_batch: (CommitBatchArguments) -> ();

  // Save the batch operations for later commit
  propose_commit_batch: (CommitBatchArguments) -> ();

  // Given a batch already proposed, perform all operations successfully, or reject
  commit_proposed_batch: (CommitProposedBatchArguments) -> ();

  // Compute a hash over the CommitBatchArguments.  Call until it returns Some(evidence).
  compute_evidence: (ComputeEvidenceArguments) -> (opt blob);

  // Delete a batch that has been created, or proposed for commit, but not yet committed
  delete_batch: (DeleteBatchArguments) -> ();

  create_asset: (CreateAssetArguments) -> ();
  set_asset_content: (SetAssetContentArguments) -> ();
  unset_asset_content: (UnsetAssetContentArguments) -> ();

  delete_asset: (DeleteAssetArguments) -> ();

  clear: (ClearArguments) -> ();

  // Single call to create an asset with content for a single content encoding that
  // fits within the message ingress limit.
  store: (record {
    key: Key;
    content_type: text;
    content_encoding: text;
    content: blob;
    sha256: opt blob
  }) -> ();

  http_request: (request: HttpRequest) -> (HttpResponse) query;
  http_request_streaming_callback: (token: StreamingCallbackToken) -> (opt StreamingCallbackHttpResponse) query;

  authorize: (principal) -> ();
  deauthorize: (principal) -> ();
  list_authorized: () -> (vec principal);
  grant_permission: (GrantPermission) -> ();
  revoke_permission: (RevokePermission) -> ();
  list_permitted: (ListPermitted) -> (vec principal);
  take_ownership: () -> ();

  get_asset_properties : (key: Key) -> (record {
    max_age: opt nat64;
    headers: opt vec HeaderField;
    allow_raw_access: opt bool;
    is_aliased: opt bool; } ) query;
  set_asset_properties: (SetAssetPropertiesArguments) -> ();

  get_configuration: () -> (ConfigurationResponse);
  configure: (ConfigureArguments) -> ();

  validate_grant_permission: (GrantPermission) -> (ValidationResult);
  validate_revoke_permission: (RevokePermission) -> (ValidationResult);
  validate_take_ownership: () -> (ValidationResult);
  validate_commit_proposed_batch: (CommitProposedBatchArguments) -> (ValidationResult);
  validate_configure: (ConfigureArguments) -> (ValidationResult);
}

================
File: src/declarations/frontend/frontend.did.d.ts
================
import type { Principal } from '@dfinity/principal';
import type { ActorMethod } from '@dfinity/agent';
import type { IDL } from '@dfinity/candid';

export type AssetCanisterArgs = { 'Upgrade' : UpgradeArgs } |
  { 'Init' : InitArgs };
export type BatchId = bigint;
export type BatchOperationKind = {
    'SetAssetProperties' : SetAssetPropertiesArguments
  } |
  { 'CreateAsset' : CreateAssetArguments } |
  { 'UnsetAssetContent' : UnsetAssetContentArguments } |
  { 'DeleteAsset' : DeleteAssetArguments } |
  { 'SetAssetContent' : SetAssetContentArguments } |
  { 'Clear' : ClearArguments };
export type ChunkId = bigint;
export type ClearArguments = {};
export interface CommitBatchArguments {
  'batch_id' : BatchId,
  'operations' : Array<BatchOperationKind>,
}
export interface CommitProposedBatchArguments {
  'batch_id' : BatchId,
  'evidence' : Uint8Array | number[],
}
export interface ComputeEvidenceArguments {
  'batch_id' : BatchId,
  'max_iterations' : [] | [number],
}
export interface ConfigurationResponse {
  'max_batches' : [] | [bigint],
  'max_bytes' : [] | [bigint],
  'max_chunks' : [] | [bigint],
}
export interface ConfigureArguments {
  'max_batches' : [] | [[] | [bigint]],
  'max_bytes' : [] | [[] | [bigint]],
  'max_chunks' : [] | [[] | [bigint]],
}
export interface CreateAssetArguments {
  'key' : Key,
  'content_type' : string,
  'headers' : [] | [Array<HeaderField>],
  'allow_raw_access' : [] | [boolean],
  'max_age' : [] | [bigint],
  'enable_aliasing' : [] | [boolean],
}
export interface DeleteAssetArguments { 'key' : Key }
export interface DeleteBatchArguments { 'batch_id' : BatchId }
export interface GrantPermission {
  'permission' : Permission,
  'to_principal' : Principal,
}
export type HeaderField = [string, string];
export interface HttpRequest {
  'url' : string,
  'method' : string,
  'body' : Uint8Array | number[],
  'headers' : Array<HeaderField>,
  'certificate_version' : [] | [number],
}
export interface HttpResponse {
  'body' : Uint8Array | number[],
  'headers' : Array<HeaderField>,
  'streaming_strategy' : [] | [StreamingStrategy],
  'status_code' : number,
}
export interface InitArgs { 'set_permissions' : [] | [SetPermissions] }
export type Key = string;
export interface ListPermitted { 'permission' : Permission }
export type Permission = { 'Prepare' : null } |
  { 'ManagePermissions' : null } |
  { 'Commit' : null };
export interface RevokePermission {
  'permission' : Permission,
  'of_principal' : Principal,
}
export interface SetAssetContentArguments {
  'key' : Key,
  'sha256' : [] | [Uint8Array | number[]],
  'chunk_ids' : Array<ChunkId>,
  'content_encoding' : string,
}
export interface SetAssetPropertiesArguments {
  'key' : Key,
  'headers' : [] | [[] | [Array<HeaderField>]],
  'is_aliased' : [] | [[] | [boolean]],
  'allow_raw_access' : [] | [[] | [boolean]],
  'max_age' : [] | [[] | [bigint]],
}
export interface SetPermissions {
  'prepare' : Array<Principal>,
  'commit' : Array<Principal>,
  'manage_permissions' : Array<Principal>,
}
export interface StreamingCallbackHttpResponse {
  'token' : [] | [StreamingCallbackToken],
  'body' : Uint8Array | number[],
}
export interface StreamingCallbackToken {
  'key' : Key,
  'sha256' : [] | [Uint8Array | number[]],
  'index' : bigint,
  'content_encoding' : string,
}
export type StreamingStrategy = {
    'Callback' : {
      'token' : StreamingCallbackToken,
      'callback' : [Principal, string],
    }
  };
export type Time = bigint;
export interface UnsetAssetContentArguments {
  'key' : Key,
  'content_encoding' : string,
}
export interface UpgradeArgs { 'set_permissions' : [] | [SetPermissions] }
export type ValidationResult = { 'Ok' : string } |
  { 'Err' : string };
export interface _SERVICE {
  'api_version' : ActorMethod<[], number>,
  'authorize' : ActorMethod<[Principal], undefined>,
  'certified_tree' : ActorMethod<
    [{}],
    { 'certificate' : Uint8Array | number[], 'tree' : Uint8Array | number[] }
  >,
  'clear' : ActorMethod<[ClearArguments], undefined>,
  'commit_batch' : ActorMethod<[CommitBatchArguments], undefined>,
  'commit_proposed_batch' : ActorMethod<
    [CommitProposedBatchArguments],
    undefined
  >,
  'compute_evidence' : ActorMethod<
    [ComputeEvidenceArguments],
    [] | [Uint8Array | number[]]
  >,
  'configure' : ActorMethod<[ConfigureArguments], undefined>,
  'create_asset' : ActorMethod<[CreateAssetArguments], undefined>,
  'create_batch' : ActorMethod<[{}], { 'batch_id' : BatchId }>,
  'create_chunk' : ActorMethod<
    [{ 'content' : Uint8Array | number[], 'batch_id' : BatchId }],
    { 'chunk_id' : ChunkId }
  >,
  'create_chunks' : ActorMethod<
    [{ 'content' : Array<Uint8Array | number[]>, 'batch_id' : BatchId }],
    { 'chunk_ids' : Array<ChunkId> }
  >,
  'deauthorize' : ActorMethod<[Principal], undefined>,
  'delete_asset' : ActorMethod<[DeleteAssetArguments], undefined>,
  'delete_batch' : ActorMethod<[DeleteBatchArguments], undefined>,
  'get' : ActorMethod<
    [{ 'key' : Key, 'accept_encodings' : Array<string> }],
    {
      'content' : Uint8Array | number[],
      'sha256' : [] | [Uint8Array | number[]],
      'content_type' : string,
      'content_encoding' : string,
      'total_length' : bigint,
    }
  >,
  'get_asset_properties' : ActorMethod<
    [Key],
    {
      'headers' : [] | [Array<HeaderField>],
      'is_aliased' : [] | [boolean],
      'allow_raw_access' : [] | [boolean],
      'max_age' : [] | [bigint],
    }
  >,
  'get_chunk' : ActorMethod<
    [
      {
        'key' : Key,
        'sha256' : [] | [Uint8Array | number[]],
        'index' : bigint,
        'content_encoding' : string,
      },
    ],
    { 'content' : Uint8Array | number[] }
  >,
  'get_configuration' : ActorMethod<[], ConfigurationResponse>,
  'grant_permission' : ActorMethod<[GrantPermission], undefined>,
  'http_request' : ActorMethod<[HttpRequest], HttpResponse>,
  'http_request_streaming_callback' : ActorMethod<
    [StreamingCallbackToken],
    [] | [StreamingCallbackHttpResponse]
  >,
  'list' : ActorMethod<
    [{}],
    Array<
      {
        'key' : Key,
        'encodings' : Array<
          {
            'modified' : Time,
            'sha256' : [] | [Uint8Array | number[]],
            'length' : bigint,
            'content_encoding' : string,
          }
        >,
        'content_type' : string,
      }
    >
  >,
  'list_authorized' : ActorMethod<[], Array<Principal>>,
  'list_permitted' : ActorMethod<[ListPermitted], Array<Principal>>,
  'propose_commit_batch' : ActorMethod<[CommitBatchArguments], undefined>,
  'revoke_permission' : ActorMethod<[RevokePermission], undefined>,
  'set_asset_content' : ActorMethod<[SetAssetContentArguments], undefined>,
  'set_asset_properties' : ActorMethod<
    [SetAssetPropertiesArguments],
    undefined
  >,
  'store' : ActorMethod<
    [
      {
        'key' : Key,
        'content' : Uint8Array | number[],
        'sha256' : [] | [Uint8Array | number[]],
        'content_type' : string,
        'content_encoding' : string,
      },
    ],
    undefined
  >,
  'take_ownership' : ActorMethod<[], undefined>,
  'unset_asset_content' : ActorMethod<[UnsetAssetContentArguments], undefined>,
  'validate_commit_proposed_batch' : ActorMethod<
    [CommitProposedBatchArguments],
    ValidationResult
  >,
  'validate_configure' : ActorMethod<[ConfigureArguments], ValidationResult>,
  'validate_grant_permission' : ActorMethod<
    [GrantPermission],
    ValidationResult
  >,
  'validate_revoke_permission' : ActorMethod<
    [RevokePermission],
    ValidationResult
  >,
  'validate_take_ownership' : ActorMethod<[], ValidationResult>,
}
export declare const idlFactory: IDL.InterfaceFactory;
export declare const init: (args: { IDL: typeof IDL }) => IDL.Type[];

================
File: src/declarations/frontend/frontend.did.js
================
export const idlFactory = ({ IDL }) => {
  const SetPermissions = IDL.Record({
    'prepare' : IDL.Vec(IDL.Principal),
    'commit' : IDL.Vec(IDL.Principal),
    'manage_permissions' : IDL.Vec(IDL.Principal),
  });
  const UpgradeArgs = IDL.Record({
    'set_permissions' : IDL.Opt(SetPermissions),
  });
  const InitArgs = IDL.Record({ 'set_permissions' : IDL.Opt(SetPermissions) });
  const AssetCanisterArgs = IDL.Variant({
    'Upgrade' : UpgradeArgs,
    'Init' : InitArgs,
  });
  const ClearArguments = IDL.Record({});
  const BatchId = IDL.Nat;
  const Key = IDL.Text;
  const HeaderField = IDL.Tuple(IDL.Text, IDL.Text);
  const SetAssetPropertiesArguments = IDL.Record({
    'key' : Key,
    'headers' : IDL.Opt(IDL.Opt(IDL.Vec(HeaderField))),
    'is_aliased' : IDL.Opt(IDL.Opt(IDL.Bool)),
    'allow_raw_access' : IDL.Opt(IDL.Opt(IDL.Bool)),
    'max_age' : IDL.Opt(IDL.Opt(IDL.Nat64)),
  });
  const CreateAssetArguments = IDL.Record({
    'key' : Key,
    'content_type' : IDL.Text,
    'headers' : IDL.Opt(IDL.Vec(HeaderField)),
    'allow_raw_access' : IDL.Opt(IDL.Bool),
    'max_age' : IDL.Opt(IDL.Nat64),
    'enable_aliasing' : IDL.Opt(IDL.Bool),
  });
  const UnsetAssetContentArguments = IDL.Record({
    'key' : Key,
    'content_encoding' : IDL.Text,
  });
  const DeleteAssetArguments = IDL.Record({ 'key' : Key });
  const ChunkId = IDL.Nat;
  const SetAssetContentArguments = IDL.Record({
    'key' : Key,
    'sha256' : IDL.Opt(IDL.Vec(IDL.Nat8)),
    'chunk_ids' : IDL.Vec(ChunkId),
    'content_encoding' : IDL.Text,
  });
  const BatchOperationKind = IDL.Variant({
    'SetAssetProperties' : SetAssetPropertiesArguments,
    'CreateAsset' : CreateAssetArguments,
    'UnsetAssetContent' : UnsetAssetContentArguments,
    'DeleteAsset' : DeleteAssetArguments,
    'SetAssetContent' : SetAssetContentArguments,
    'Clear' : ClearArguments,
  });
  const CommitBatchArguments = IDL.Record({
    'batch_id' : BatchId,
    'operations' : IDL.Vec(BatchOperationKind),
  });
  const CommitProposedBatchArguments = IDL.Record({
    'batch_id' : BatchId,
    'evidence' : IDL.Vec(IDL.Nat8),
  });
  const ComputeEvidenceArguments = IDL.Record({
    'batch_id' : BatchId,
    'max_iterations' : IDL.Opt(IDL.Nat16),
  });
  const ConfigureArguments = IDL.Record({
    'max_batches' : IDL.Opt(IDL.Opt(IDL.Nat64)),
    'max_bytes' : IDL.Opt(IDL.Opt(IDL.Nat64)),
    'max_chunks' : IDL.Opt(IDL.Opt(IDL.Nat64)),
  });
  const DeleteBatchArguments = IDL.Record({ 'batch_id' : BatchId });
  const ConfigurationResponse = IDL.Record({
    'max_batches' : IDL.Opt(IDL.Nat64),
    'max_bytes' : IDL.Opt(IDL.Nat64),
    'max_chunks' : IDL.Opt(IDL.Nat64),
  });
  const Permission = IDL.Variant({
    'Prepare' : IDL.Null,
    'ManagePermissions' : IDL.Null,
    'Commit' : IDL.Null,
  });
  const GrantPermission = IDL.Record({
    'permission' : Permission,
    'to_principal' : IDL.Principal,
  });
  const HttpRequest = IDL.Record({
    'url' : IDL.Text,
    'method' : IDL.Text,
    'body' : IDL.Vec(IDL.Nat8),
    'headers' : IDL.Vec(HeaderField),
    'certificate_version' : IDL.Opt(IDL.Nat16),
  });
  const StreamingCallbackToken = IDL.Record({
    'key' : Key,
    'sha256' : IDL.Opt(IDL.Vec(IDL.Nat8)),
    'index' : IDL.Nat,
    'content_encoding' : IDL.Text,
  });
  const StreamingCallbackHttpResponse = IDL.Record({
    'token' : IDL.Opt(StreamingCallbackToken),
    'body' : IDL.Vec(IDL.Nat8),
  });
  const StreamingStrategy = IDL.Variant({
    'Callback' : IDL.Record({
      'token' : StreamingCallbackToken,
      'callback' : IDL.Func(
          [StreamingCallbackToken],
          [IDL.Opt(StreamingCallbackHttpResponse)],
          ['query'],
        ),
    }),
  });
  const HttpResponse = IDL.Record({
    'body' : IDL.Vec(IDL.Nat8),
    'headers' : IDL.Vec(HeaderField),
    'streaming_strategy' : IDL.Opt(StreamingStrategy),
    'status_code' : IDL.Nat16,
  });
  const Time = IDL.Int;
  const ListPermitted = IDL.Record({ 'permission' : Permission });
  const RevokePermission = IDL.Record({
    'permission' : Permission,
    'of_principal' : IDL.Principal,
  });
  const ValidationResult = IDL.Variant({ 'Ok' : IDL.Text, 'Err' : IDL.Text });
  return IDL.Service({
    'api_version' : IDL.Func([], [IDL.Nat16], ['query']),
    'authorize' : IDL.Func([IDL.Principal], [], []),
    'certified_tree' : IDL.Func(
        [IDL.Record({})],
        [
          IDL.Record({
            'certificate' : IDL.Vec(IDL.Nat8),
            'tree' : IDL.Vec(IDL.Nat8),
          }),
        ],
        ['query'],
      ),
    'clear' : IDL.Func([ClearArguments], [], []),
    'commit_batch' : IDL.Func([CommitBatchArguments], [], []),
    'commit_proposed_batch' : IDL.Func([CommitProposedBatchArguments], [], []),
    'compute_evidence' : IDL.Func(
        [ComputeEvidenceArguments],
        [IDL.Opt(IDL.Vec(IDL.Nat8))],
        [],
      ),
    'configure' : IDL.Func([ConfigureArguments], [], []),
    'create_asset' : IDL.Func([CreateAssetArguments], [], []),
    'create_batch' : IDL.Func(
        [IDL.Record({})],
        [IDL.Record({ 'batch_id' : BatchId })],
        [],
      ),
    'create_chunk' : IDL.Func(
        [IDL.Record({ 'content' : IDL.Vec(IDL.Nat8), 'batch_id' : BatchId })],
        [IDL.Record({ 'chunk_id' : ChunkId })],
        [],
      ),
    'create_chunks' : IDL.Func(
        [
          IDL.Record({
            'content' : IDL.Vec(IDL.Vec(IDL.Nat8)),
            'batch_id' : BatchId,
          }),
        ],
        [IDL.Record({ 'chunk_ids' : IDL.Vec(ChunkId) })],
        [],
      ),
    'deauthorize' : IDL.Func([IDL.Principal], [], []),
    'delete_asset' : IDL.Func([DeleteAssetArguments], [], []),
    'delete_batch' : IDL.Func([DeleteBatchArguments], [], []),
    'get' : IDL.Func(
        [IDL.Record({ 'key' : Key, 'accept_encodings' : IDL.Vec(IDL.Text) })],
        [
          IDL.Record({
            'content' : IDL.Vec(IDL.Nat8),
            'sha256' : IDL.Opt(IDL.Vec(IDL.Nat8)),
            'content_type' : IDL.Text,
            'content_encoding' : IDL.Text,
            'total_length' : IDL.Nat,
          }),
        ],
        ['query'],
      ),
    'get_asset_properties' : IDL.Func(
        [Key],
        [
          IDL.Record({
            'headers' : IDL.Opt(IDL.Vec(HeaderField)),
            'is_aliased' : IDL.Opt(IDL.Bool),
            'allow_raw_access' : IDL.Opt(IDL.Bool),
            'max_age' : IDL.Opt(IDL.Nat64),
          }),
        ],
        ['query'],
      ),
    'get_chunk' : IDL.Func(
        [
          IDL.Record({
            'key' : Key,
            'sha256' : IDL.Opt(IDL.Vec(IDL.Nat8)),
            'index' : IDL.Nat,
            'content_encoding' : IDL.Text,
          }),
        ],
        [IDL.Record({ 'content' : IDL.Vec(IDL.Nat8) })],
        ['query'],
      ),
    'get_configuration' : IDL.Func([], [ConfigurationResponse], []),
    'grant_permission' : IDL.Func([GrantPermission], [], []),
    'http_request' : IDL.Func([HttpRequest], [HttpResponse], ['query']),
    'http_request_streaming_callback' : IDL.Func(
        [StreamingCallbackToken],
        [IDL.Opt(StreamingCallbackHttpResponse)],
        ['query'],
      ),
    'list' : IDL.Func(
        [IDL.Record({})],
        [
          IDL.Vec(
            IDL.Record({
              'key' : Key,
              'encodings' : IDL.Vec(
                IDL.Record({
                  'modified' : Time,
                  'sha256' : IDL.Opt(IDL.Vec(IDL.Nat8)),
                  'length' : IDL.Nat,
                  'content_encoding' : IDL.Text,
                })
              ),
              'content_type' : IDL.Text,
            })
          ),
        ],
        ['query'],
      ),
    'list_authorized' : IDL.Func([], [IDL.Vec(IDL.Principal)], []),
    'list_permitted' : IDL.Func([ListPermitted], [IDL.Vec(IDL.Principal)], []),
    'propose_commit_batch' : IDL.Func([CommitBatchArguments], [], []),
    'revoke_permission' : IDL.Func([RevokePermission], [], []),
    'set_asset_content' : IDL.Func([SetAssetContentArguments], [], []),
    'set_asset_properties' : IDL.Func([SetAssetPropertiesArguments], [], []),
    'store' : IDL.Func(
        [
          IDL.Record({
            'key' : Key,
            'content' : IDL.Vec(IDL.Nat8),
            'sha256' : IDL.Opt(IDL.Vec(IDL.Nat8)),
            'content_type' : IDL.Text,
            'content_encoding' : IDL.Text,
          }),
        ],
        [],
        [],
      ),
    'take_ownership' : IDL.Func([], [], []),
    'unset_asset_content' : IDL.Func([UnsetAssetContentArguments], [], []),
    'validate_commit_proposed_batch' : IDL.Func(
        [CommitProposedBatchArguments],
        [ValidationResult],
        [],
      ),
    'validate_configure' : IDL.Func(
        [ConfigureArguments],
        [ValidationResult],
        [],
      ),
    'validate_grant_permission' : IDL.Func(
        [GrantPermission],
        [ValidationResult],
        [],
      ),
    'validate_revoke_permission' : IDL.Func(
        [RevokePermission],
        [ValidationResult],
        [],
      ),
    'validate_take_ownership' : IDL.Func([], [ValidationResult], []),
  });
};
export const init = ({ IDL }) => {
  const SetPermissions = IDL.Record({
    'prepare' : IDL.Vec(IDL.Principal),
    'commit' : IDL.Vec(IDL.Principal),
    'manage_permissions' : IDL.Vec(IDL.Principal),
  });
  const UpgradeArgs = IDL.Record({
    'set_permissions' : IDL.Opt(SetPermissions),
  });
  const InitArgs = IDL.Record({ 'set_permissions' : IDL.Opt(SetPermissions) });
  const AssetCanisterArgs = IDL.Variant({
    'Upgrade' : UpgradeArgs,
    'Init' : InitArgs,
  });
  return [IDL.Opt(AssetCanisterArgs)];
};

================
File: src/declarations/frontend/index.d.ts
================
import type {
  ActorSubclass,
  HttpAgentOptions,
  ActorConfig,
  Agent,
} from "@dfinity/agent";
import type { Principal } from "@dfinity/principal";
import type { IDL } from "@dfinity/candid";

import { _SERVICE } from './frontend.did';

export declare const idlFactory: IDL.InterfaceFactory;
export declare const canisterId: string;

export declare interface CreateActorOptions {
  /**
   * @see {@link Agent}
   */
  agent?: Agent;
  /**
   * @see {@link HttpAgentOptions}
   */
  agentOptions?: HttpAgentOptions;
  /**
   * @see {@link ActorConfig}
   */
  actorOptions?: ActorConfig;
}

/**
 * Intializes an {@link ActorSubclass}, configured with the provided SERVICE interface of a canister.
 * @constructs {@link ActorSubClass}
 * @param {string | Principal} canisterId - ID of the canister the {@link Actor} will talk to
 * @param {CreateActorOptions} options - see {@link CreateActorOptions}
 * @param {CreateActorOptions["agent"]} options.agent - a pre-configured agent you'd like to use. Supercedes agentOptions
 * @param {CreateActorOptions["agentOptions"]} options.agentOptions - options to set up a new agent
 * @see {@link HttpAgentOptions}
 * @param {CreateActorOptions["actorOptions"]} options.actorOptions - options for the Actor
 * @see {@link ActorConfig}
 */
export declare const createActor: (
  canisterId: string | Principal,
  options?: CreateActorOptions
) => ActorSubclass<_SERVICE>;

/**
 * Intialized Actor using default settings, ready to talk to a canister using its candid interface
 * @constructs {@link ActorSubClass}
 */
export declare const frontend: ActorSubclass<_SERVICE>;

================
File: src/declarations/frontend/index.js
================
import { Actor, HttpAgent } from "@dfinity/agent";

// Imports and re-exports candid interface
import { idlFactory } from "./frontend.did.js";
export { idlFactory } from "./frontend.did.js";

/* CANISTER_ID is replaced by webpack based on node environment
 * Note: canister environment variable will be standardized as
 * process.env.CANISTER_ID_<CANISTER_NAME_UPPERCASE>
 * beginning in dfx 0.15.0
 */
export const canisterId =
  process.env.CANISTER_ID_FRONTEND;

export const createActor = (canisterId, options = {}) => {
  const agent = options.agent || new HttpAgent({ ...options.agentOptions });

  if (options.agent && options.agentOptions) {
    console.warn(
      "Detected both agent and agentOptions passed to createActor. Ignoring agentOptions and proceeding with the provided agent."
    );
  }

  // Fetch root key for certificate validation during development
  if (process.env.DFX_NETWORK !== "ic") {
    agent.fetchRootKey().catch((err) => {
      console.warn(
        "Unable to fetch root key. Check to ensure that your local replica is running"
      );
      console.error(err);
    });
  }

  // Creates an actor with using the candid interface and the HttpAgent
  return Actor.createActor(idlFactory, {
    agent,
    canisterId,
    ...options.actorOptions,
  });
};

export const frontend = canisterId ? createActor(canisterId) : undefined;

================
File: src/frontend/src/routes/page/+page.svelte
================
<!-- src/frontend/src/routes/protected/+page.svelte -->
<script lang="ts">
    import '../../app.css';
  </script>
  
  <main>
    <h1>Protected Page</h1>
    
    <div class="success-box">
      <p> This is a protected page</p>
      <p>You're seeing this content because you've successfully authenticated with a valid NFC tag.</p>
    </div>
    
    <a href="/" class="button">Back to Home</a>
  </main>
  
  <style>
    .success-box {
      background-color: #d4edda;
      color: #155724;
      padding: 1rem;
      margin: 1rem 0;
      border-radius: 5px;
      border-left: 5px solid #28a745;
    }

    .button {
      display: inline-block;
      background-color: #007bff;
      color: white;
      padding: 0.5rem 1rem;
      text-decoration: none;
      border-radius: 5px;
      margin-top: 1rem;
    }
    
    .button:hover {
      background-color: #0069d9;
    }

  </style>

================
File: src/frontend/src/routes/+layout.ts
================
export const prerender = true;
import { goto } from '$app/navigation';
import { browser } from '$app/environment';
import { ic } from '../stores/ic';
import type { LayoutLoad } from './$types';

export const load: LayoutLoad = async ({ url }) => {
  if (!browser) return { protected: false };
  
  // const ic = createActor();
  const currentPath = url.pathname.substring(1);
  
  try {
    // Check if route is protected
    const isProtected = await $ic.actor.is_protected_route(currentPath);
    console.log('HERE', isProtected);
    
    if (isProtected) {
      // Validate the NFC scan
      const isValid = await ic.actor.validate_url_scan(url.href, currentPath);
      
      if (!isValid) {
        // Redirect to error page if scan is invalid
        goto('/edge.html');
        return { protected: true, valid: false };
      }
      
      return { protected: true, valid: true };
    }
    
    // Not a protected route
    return { protected: false };
  } catch (error) {
    console.error('Error checking route protection:', error);
    return { protected: false, error: true };
  }
}

================
File: src/frontend/src/routes/+page.svelte
================
<script lang="ts">
	 	import { ic } from '../stores/ic';
		import '../app.css';

	let input = '', greeting = '', loading = false;

	const handleOnSubmit = async () => {
		loading = true;
		greeting = 'loading ...';
		try {
			// Call the IC
			// greeting = await $ic.actor.sayHelloTo(input);
			// loading = false;

		} catch (err: unknown) {
			console.error(err);
		}
	};

	const backendCanisterId = import.meta.env.VITE_BACKEND_CANISTER_ID;
</script>

<main>

	<img src="icAcademy.png" alt="IcAcademy logo" />
	<h1>My Demo App</h1>

	<div class="canister-info">
		<p>Backend Canister ID: <span class="highlight">{backendCanisterId}</span></p>
	</div>

	<div id="info">
		<div>
			This example demonstrates how to interact with a canister using <span class="highlight">import.meta.env.VITE_*</span> variables.
		</div>
		<br/>
		<div>
			Greet someone with <span class="highlight">an unauthenticated call</span> to the IC.
		</div>

		<form on:submit|preventDefault={handleOnSubmit}>
			<input id="name" alt="Name" type="text" bind:value={input} placeholder="Say hello to"/>
			<button type="submit" disabled={loading} >Click Me!</button>
		</form>

		<div id="greeting"> {greeting} </div>
	</div>
</main>

<style>
	form input {
		width: 50%;
		padding: 0.5rem;
		margin: 0.5rem 0;
		border: 1px solid #ccc;
		border-radius: 5px;
	}
	#greeting {
		width: 100%;
		min-height: 20px;
		border: 1px solid #222;
		padding: 0.5rem;
		margin: 0.5rem 0;
	}
	#info {
		max-width: 100%;
		margin: 10px auto;
		padding: 20px;
	}
</style>

================
File: src/frontend/src/routes/layout.svelte
================
<script>
    export let data;
  </script>
  
  {#if data.protected && !data.valid}
    <!-- Show loading or redirecting message -->
    <div>Validating NFC tag...</div>
  {:else}
    <slot />
  {/if}

================
File: src/frontend/src/stores/ic.ts
================
import { writable } from "svelte/store";

// @ts-ignore
import { idlFactory } from "../../../declarations/backend/backend.did.js";
import { Actor, HttpAgent } from "@dfinity/agent";

import type { ActorSubclass } from "@dfinity/agent";
import type { _SERVICE } from "../../../declarations/backend/backend.did";

/**
 * Creates an actor for the Backend canister
 */
type OptionsType = {
  agentOptions?: import("@dfinity/agent").HttpAgentOptions;
  actorOptions?: import("@dfinity/agent").ActorConfig;
};

type ReturnType = {
  actor: import("@dfinity/agent").ActorSubclass<import("../../../declarations/backend/backend.did")._SERVICE>;
};

export function createActor(options?:OptionsType):ReturnType {
  let _host = 'http://localhost:4943';
  let hosts =['ic', 'playground'];

  if(hosts.includes(import.meta.env.VITE_DFX_NETWORK)) {
    _host = `https://${import.meta.env.VITE_BACKEND_CANISTER_ID}.ic0.app`;
  }
  
  const hostOptions = { host: _host};
  if (!options) {
    options = {
      agentOptions: hostOptions,
    };
  } else if (!options.agentOptions) {
    options.agentOptions = hostOptions;
  } else {
    options.agentOptions.host = hostOptions.host;
  }

  const agent = HttpAgent.createSync({ ...options.agentOptions });
  
  // Fetch root key for certificate validation during development
  if (import.meta.env.VITE_DFX_NETWORK !== "ic") {
    agent.fetchRootKey().catch((err) => {
      console.warn(
        "Unable to fetch root key. Check to ensure that your local replica is running"
      );
      console.error(err);
    });
  }

  // Creates an actor with using the candid interface and the HttpAgent
  return Actor.createActor(idlFactory, {
    agent,
    canisterId: import.meta.env.VITE_BACKEND_CANISTER_ID || "",
    ...options?.actorOptions,
  });
}
// create importable store for the actor
// you can import this store in any svelte component to make calls to the backend
export const ic = writable<ReturnType>({
  actor: createActor() as unknown as ActorSubclass<_SERVICE>,
});

================
File: src/frontend/src/app.css
================
main {
  font-family: sans-serif;
  max-width: 1024px;
}

img {
  max-width: 150px;
  display: block;
  margin: auto;
}

form {
  display: flex;
  justify-content: center;
  gap: 0.5em;
  flex-flow: row wrap;
  max-width: 40vw;
  margin: auto;
  align-items: baseline;
  font-size: 1.5rem;
}

h1 {
  text-align: center;
}

button[type='submit'] {
  padding: 5px 20px;
  margin: 10px auto;
  float: right;
}

.highlight {
  background-color: rgb(245, 237, 86);
  border-radius: 5px;
  padding: 0 5px;
}

================
File: src/frontend/src/app.d.ts
================
// See https://kit.svelte.dev/docs/types#app
// for information about these interfaces
// and what to do when importing types
declare namespace App {
	// interface Locals {}
	// interface PageData {}
	// interface Error {}
	// interface Platform {}
}

================
File: src/frontend/src/app.html
================
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="%sveltekit.assets%/favicon.ico" />
		<meta name="viewport" content="width=device-width" />
		%sveltekit.head%
	</head>
	<body>
		<div>%sveltekit.body%</div>
	</body>
</html>

================
File: src/frontend/static/edge.html
================
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Invalid scan sorry bro, try again with the real tag!</title>
    <style>
        body {
            background: linear-gradient(135deg, #ff007f, #007fff);
            color: #fff;
            font-family: 'Arial Black', sans-serif;
            text-align: center;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        h1 {
            font-size: 4rem;
            text-transform: uppercase;
            margin-top: 20vh;
            text-shadow: 2px 2px 10px rgba(0, 0, 0, 0.8);
        }
        p {
            font-size: 1.5rem;
            margin: 1rem auto;
            max-width: 800px;
        }
        a {
            text-decoration: none;
            color: #fff;
            padding: 10px 20px;
            border: 2px solid #fff;
            border-radius: 25px;
            transition: all 0.3s ease;
        }
        a:hover {
            background-color: #fff;
            color: #007fff;
        }
        .neon {
            animation: neon-flicker 1.5s infinite;
        }
        @keyframes neon-flicker {
            0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
                text-shadow: 
                    0 0 5px #fff,
                    0 0 10px #fff,
                    0 0 20px #ff007f,
                    0 0 30px #ff007f,
                    0 0 40px #ff007f,
                    0 0 50px #ff007f,
                    0 0 75px #ff007f;
            }
            20%, 24%, 55% {
                text-shadow: none;
            }
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }

        .ii-button {
            background-color: #29ABE2;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }

        .ii-button:hover {
            background-color: #1a8ac0;
        }
    </style>
</head>
<body>
    <canvas id="bg"></canvas>
    <h1 class="neon">Invalid scan<br />sorry bro!</h1>
    <p>try again with the real tag!</p>


    <script>
        // Edgy dynamic background
        const canvas = document.getElementById('bg');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        let particles = [];
        const colors = ['#ff007f', '#007fff', '#ffdd00'];

        class Particle {
            constructor() {
                this.x = Math.random() * canvas.width;
                this.y = Math.random() * canvas.height;
                this.radius = Math.random() * 3 + 1;
                this.color = colors[Math.floor(Math.random() * colors.length)];
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = (Math.random() - 0.5) * 2;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;

                if (this.x < 0 || this.x > canvas.width) this.vx *= -1;
                if (this.y < 0 || this.y > canvas.height) this.vy *= -1;
            }
        }

        function initParticles() {
            for (let i = 0; i < 100; i++) {
                particles.push(new Particle());
            }
        }

        function animate() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            particles.forEach(particle => {
                particle.update();
                particle.draw();
            });
            requestAnimationFrame(animate);
        }

        initParticles();
        animate();

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            particles = [];
            initParticles();
        });
    </script>


</body>
</html>

================
File: .eslintignore
================
.DS_Store
node_modules
/build
/.svelte-kit
/package
.env
.env.*
!.env.example

# Ignore files for PNPM, NPM and YARN
pnpm-lock.yaml
package-lock.json
yarn.lock

src/declarations

================
File: .eslintrc.cjs
================
module.exports = {
	root: true,
	parser: '@typescript-eslint/parser',
	extends: ['eslint:recommended', 'plugin:@typescript-eslint/recommended', 'prettier'],
	plugins: ['svelte3', '@typescript-eslint'],
	ignorePatterns: ['*.cjs'],
	overrides: [{ files: ['*.svelte'], processor: 'svelte3/svelte3' }],
	settings: {
		'svelte3/typescript': () => require('typescript')
	},
	parserOptions: {
		sourceType: 'module',
		ecmaVersion: 2020
	},
	env: {
		browser: true,
		es2017: true,
		node: true
	}
};

================
File: .gitignore
================
.DS_Store
node_modules
/build
/.svelte-kit
/package
.env
.env.*
!.env.example
.dfx
target

================
File: .npmrc
================
engine-strict=true

================
File: .prettierignore
================
.DS_Store
node_modules
/build
/.svelte-kit
/package
.env
.env.*
!.env.example

# Ignore files for PNPM, NPM and YARN
pnpm-lock.yaml
package-lock.json
yarn.lock

.dfx

================
File: .prettierrc
================
{
	"useTabs": true,
	"singleQuote": true,
	"trailingComma": "none",
	"printWidth": 100,
	"plugins": ["prettier-plugin-svelte"],
	"overrides": [{ "files": "*.svelte", "options": { "parser": "svelte" } }]
}

================
File: cmacs.json
================
["164387df8d5ca2c999c4e37b0047714fd329ac89751f6e11a5b0316c918c5d02", "271fe579616ff23dee73d13bed888c5f268a1a8ee94a02ab875152c692fa9095", "f49763596935e6625cb428cbc55ebd848d5583518cf452f9b831e2b340426fed", "b6d72c43bc90e2f7063b31f9caab8848375bc06992161891cd2d725eafeb3801", "00df7d78553140cd8b7dde1c6b6bdc8907ecd1dd94b2b458e9eaa78eae96ed75", "c07c8ca5e39e842cac4baafd9394ec95438cc840dc694bf58235fd194be1a904", "51db40c83c89e4eac2b670ac3d571dc02a9395e93db8557efc3205e542243314", "d9bcaefd4b0c9d5b12a7e8216ae9b75791e5fba8e07b5937abffd1c228a1317e", "4047b0b53cb6f13cd37f6ab5eae70a99b1558532909ffcaa43d85df33c1c0a86", "c1c990b214425414953c1532f09e707843c9b1742786be96467fb7a738736b4b", "80bc14fa0a7ed55f456f58c42525da84e41b2ea31518e62189fe1d2f9f0083c7", "1963a0d58d0afeb3c736d71edb7fd0df7bb5853e7a117d797a18e3c15489de4d", "59d0119745ed947b224ba2cbf5f00e9005abc3972580841a96714100f9bbe397", "290f4e30998fc623d277765b6925359d3a9c3fc7014c8acd1bfb3b0eeed444ad", "b5b526982d10d3ef7938f09ab698df448d5627e37ee843ecebeb55f625e089e1", "5f08a92e3358f1e914644c6a648a8e3f8345decca2be8ec5345f37eaedeed339", "875c6336bf75c454756e3fd48078ba8350b198e3217751787edc6cb2991bf10a", "c8cd657ba4de2882c7d08ff741b5584a9ac0aabc93c86c80c5c9b2862a2abe06", "159cd9f1cd2ca61e866fa8be95df0f1baec49a36b536e6e40e3dad42f701fdd3", "ef74f7b6b37eb94e72cb1b0fd9e8b181a97069f14b3a7ffa9bad16329dffba95", "8c493a70ac349634074a9a63b243f5e953531eb611f1714f00f28d4926527972", "ca99b758b8197ff610e92038bd32d5c5dd054122f57807481f85ce237f430bfa", "cadda1f9c4267724420c357b4d05face604d499b32dd29f73b375063e631fc16", "69ca138d1e166b4853418a85d76fe9d64abdf284937ba936f4dcd293bf0ca090", "332bb0d0a4260398bcd0171591138cd147314de19c83aa1f1aa65115c810a4dc", "295d17a6ea01cce69870ddf76896ec69aa7b8b31fca4c899de118901be39bdc2", "17ee47c491601b73916443b1154579838d9f08b07c23d412a00a54a021acbc10", "5586ead8bcaa4564fb14eb013194a802c6935de8e27c8517f52f03364083b3e9", "228f550826fb58a237fc8ead27e70c6efc8ce94d5815847738e0e175198fd765", "10191a7b355dac160ead2c9f34bd844f708cc25d28981c58abe75a7fdd251add", "2f3e619ba216dfa00673a9cf47d0b8d9d2d7448129d7004738656808d7e68545", "0a06f6308bd1072e0df68513755392c6b475360b4ac5f60b545d736162c8515d", "06bea738474559e44a799756a68dd0166684b84f25e324a6df884fe12227e2c8", "6ed2bf5f47565b3df2cffc8d5dac2ccb2d795059b4c417bac7676f9e8b5ec786", "57f3af7bf5323fce35e64a7bd30c22bd2c9de0eb81c996aeb4590a254963f505", "9f4c4d5e011de8bd0d9b110b81b5aac4a73e2e96e02f275f5811e9998dabc68b", "bb90447460ea6922c46cfef28fba92f2dde2269b9cb09afef3d5226fc99d7fcf", "abbae026bc5f36a1607b7e83dba194aee0f11a01e30a1d08ccb3afe781e5df6a", "c818d147c1f950340c124ceb041d5a9f329c6a3c616ceffcd2558e1b502b94dd", "6af4622935eca6014a68612cdc23517d70e54a5de4d83eecd381be754900c128", "1899d70c8e576fac5bae19804fe6eb5f8b133f0a1be8742fd759896e989bee02", "c3cebb45e5e13c18f21a3603aa69d3b0ad6aa2610f259b780a3154550563618e", "700b3a9527892cf44c2bb9c92a356193bda9b0125a521fef4acc9a8214a17a1f", "c010493cfc48d7f7b4a89a44cae7d2119e8e799fcfddb484e0415d8caad62421", "5a54400386de7bd532bdfd8e28486f7fc3d4cfe4193ac1d2f7ea607a7f8c3c3f", "4bf792160855a2547097a9d62be84486a7d53f986d642281eda94d9c039c7735", "6cdce01306839b2f0c8402b36ccb896939063706f9759f526cef35774403219b", "e348c2655fed738b027b53aabadebe35e228e68c89a6c93b446bbfa12126a8f5", "b4643cb51dbd641bdbf3806248690a0bdc1b1f525482138cd5ceb8bce83e2d88"]

================
File: dfx.json
================
{
	"canisters": {
		"backend": {
			"main": "src/backend/main.mo",
			"type": "motoko"
		},
		"frontend": {
			"dependencies": ["backend"],
			"frontend": {
				"entrypoint": "build/index.html"
			},
			"source": ["build/"],
			"type": "assets"
		}
	},
	"defaults": {
		"build": {
			"args": "",
			"packtool": ""
		}
	},
	"output_env_file": ".env",
	"version": 1
}

================
File: Makefile
================
include .env

#  repomix --ignore "ufr-lib/"    


REPLICA_URL := $(if $(filter ic,$(subst ',,$(DFX_NETWORK))),https://ic0.app,http://127.0.0.1:4943)
CANISTER_NAME := $(shell grep "CANISTER_ID_" .env | grep -v "INTERNET_IDENTITY\|CANISTER_ID='" | head -1 | sed 's/CANISTER_ID_\([^=]*\)=.*/\1/' | tr '[:upper:]' '[:lower:]')
CANISTER_ID := $(CANISTER_ID_$(shell echo $(CANISTER_NAME) | tr '[:lower:]' '[:upper:]'))

UNAME := $(shell uname)
ifeq ($(UNAME), Darwin)
    OPEN_CMD := open
else ifeq ($(UNAME), Linux)
    OPEN_CMD := xdg-open
else
    OPEN_CMD := start
endif

all:
	dfx deploy $(CANISTER_NAME)
	dfx canister call $(CANISTER_NAME) invalidate_cache
	
ic:
	dfx deploy --ic
	dfx canister call --ic $(CANISTER_ID) invalidate_cache

url:
	$(OPEN_CMD) http://$(CANISTER_ID).localhost:4943/

upload_assets:
	icx-asset --replica $(REPLICA_URL) --pem ~/.config/dfx/identity/raygen/identity.pem sync $(CANISTER_ID) src/frontend/
	dfx canister call $(if $(filter https://ic0.app,$(REPLICA_URL)),--ic,) $(CANISTER_NAME) invalidate_cache

setup_route_example:
	python3 scripts/setup_route.py $(CANISTER_ID) page.html --params "key=value"

random_key:
	python3 scripts/setup_route.py $(CANISTER_ID) page2.html --random-key --params "key=value"

production_ic:
	python3 scripts/setup_route.py $(CANISTER_ID) page1.html --params "key=value" --ic

reinstall:
	dfx canister install $(CANISTER_NAME) --mode=reinstall

================
File: package.json
================
{
	"name": "sveltekit-starter-icacademy-version",
	"version": "0.1.0",
	"private": true,
	"description": "Internet Computer SvelteKit starter application, using import.meta.env.VITE_ variables for configuration.",
	"keywords": [
		"Internet Computer",
		"Motoko",
		"JavaScript",
		"Canister",
		"SvelteKit"
	],
	"scripts": {
		"dev": "vite dev",
		"build": "vite build",
		"preview": "vite preview",
		"prebuild": "npm run generate",
		"generate": "dfx generate"
	},
	"devDependencies": {
		"@sveltejs/adapter-static": "^3.0.8",
		"@sveltejs/kit": "^2.5.0",
		"@sveltejs/vite-plugin-svelte": "^5.0.3",
		"@types/node": "^22.13.11",
		"svelte": "^5.25.3",
		"tslib": "^2.8.1",
		"typescript": "^5.8.2",
		"vite": "^6.2.2"
	},
	"type": "module",
	"dependencies": {
		"@dfinity/agent": "^2.3.0",
		"@dfinity/candid": "^2.3.0",
		"@dfinity/principal": "^2.3.0"
	}
}

================
File: svelte.config.js
================
import adapter from '@sveltejs/adapter-static';
import { vitePreprocess } from '@sveltejs/vite-plugin-svelte';

const filesPath = (path) => `src/frontend/${path}`;

/** @type {import('@sveltejs/kit').Config} */
const config = {
	// Consult https://github.com/sveltejs/svelte-preprocess
	// for more information about preprocessors
	preprocess: [vitePreprocess()],
	kit: {
		adapter: adapter(),
		files: {
			assets: filesPath('static'),
			params: filesPath('src/params'),
			routes: filesPath('src/routes'),
			appTemplate: filesPath('src/app.html')
		},
		alias: {
			'lib': filesPath('./src/lib')
		}
	}
};
export default config;

================
File: tsconfig.json
================
{
	"extends": "./.svelte-kit/tsconfig.json",
	"compilerOptions": {
		"allowJs": true,
		"checkJs": true,
		"esModuleInterop": true,
		"forceConsistentCasingInFileNames": true,
		"resolveJsonModule": true,
		"skipLibCheck": true,
		"sourceMap": true,
		"strict": true
	}
	// Path aliases are handled by https://kit.svelte.dev/docs/configuration#alias
	//
	// If you want to overwrite includes/excludes, make sure to copy over the relevant includes/excludes
	// from the referenced tsconfig.json - TypeScript does not merge them in
}

================
File: vite.config.ts
================
import { sveltekit } from '@sveltejs/kit/vite';
import { readFileSync } from 'fs';
import { join } from 'path';
import type { UserConfig } from 'vite';
import { defineConfig, loadEnv } from 'vite';

let network = process.env.DFX_NETWORK;
if(network === undefined){
	network = 'local';
}
const host = network === 'local' ? 'http://localhost:4943' : 'https://ic0.app';
const readCanisterIds = ({ prefix }: { prefix?: string }): Record<string, string> => {

	let canisterIdsJsonFile: string;
	if(network ==='ic'){
		canisterIdsJsonFile = join(process.cwd(), 'canister_ids.json');
	} else if(network === 'playground'){
		canisterIdsJsonFile = join(process.cwd(), '.dfx', 'playground', 'canister_ids.json');
	} else {
		canisterIdsJsonFile = join(process.cwd(), '.dfx', 'local', 'canister_ids.json');
	}

	try {
		type Details = {
			ic?: string;
			local?: string;
			playground?: string;
		};

		const config: Record<string, Details> = JSON.parse(readFileSync(canisterIdsJsonFile, 'utf-8'));

		return Object.entries(config).reduce((acc, current: [string, Details]) => {
			const [canisterName, canisterDetails] = current;
			const erg = {
				...acc,
				[`${prefix ?? ''}${canisterName.toUpperCase()}_CANISTER_ID`]:
					canisterDetails[network as keyof Details]
			};

			return erg;
		}, {});
	} catch (e) {
		throw Error(`Could not get canister ID from ${canisterIdsJsonFile}: ${e}`);
	}
};

const config: UserConfig = {
	plugins: [sveltekit()],
	build: {
		target: 'es2020'
	},
	optimizeDeps: {
		esbuildOptions: {
			// Node.js global to browser globalThis
			define: {
				global: 'globalThis'
			}
		}
	}
};

export default defineConfig(({ mode }: UserConfig): UserConfig => {
	// Expand environment - .env files - with canister IDs
	process.env = {
		...process.env,
		...loadEnv(mode ?? 'development', process.cwd()),
		...readCanisterIds({ prefix: 'VITE_' }),
		VITE_DFX_NETWORK: network,
		VITE_HOST: host
	};

	return {
		...config,
		// Backwards compatibility for auto generated types of dfx that are meant for webpack and process.env
		define: {
			'process.env': {
				...readCanisterIds({}),
				DFX_NETWORK: network
			}
		}
	};
});



================================================================
End of Codebase
================================================================
